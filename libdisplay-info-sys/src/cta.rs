/* automatically generated by rust-bindgen 0.68.1 */

pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_4_3:
    di_cta_video_format_picture_aspect_ratio = 0;
pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_16_9:
    di_cta_video_format_picture_aspect_ratio = 1;
pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_64_27 : di_cta_video_format_picture_aspect_ratio = 2 ;
pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_256_135 : di_cta_video_format_picture_aspect_ratio = 3 ;
#[doc = " CTA video format picture aspect ratio."]
pub type di_cta_video_format_picture_aspect_ratio = ::std::os::raw::c_uint;
pub const di_cta_video_format_sync_polarity_DI_CTA_VIDEO_FORMAT_SYNC_NEGATIVE:
    di_cta_video_format_sync_polarity = 0;
pub const di_cta_video_format_sync_polarity_DI_CTA_VIDEO_FORMAT_SYNC_POSITIVE:
    di_cta_video_format_sync_polarity = 1;
#[doc = " CTA video format sync pulse polarity."]
pub type di_cta_video_format_sync_polarity = ::std::os::raw::c_uint;
#[doc = " A CTA-861 video format, defined in section 4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_video_format {
    pub vic: u8,
    pub h_active: i32,
    pub v_active: i32,
    pub h_front: i32,
    pub v_front: i32,
    pub h_sync: i32,
    pub v_sync: i32,
    pub h_back: i32,
    pub v_back: i32,
    pub h_sync_polarity: di_cta_video_format_sync_polarity,
    pub v_sync_polarity: di_cta_video_format_sync_polarity,
    pub pixel_clock_hz: i64,
    pub interlaced: bool,
    pub picture_aspect_ratio: di_cta_video_format_picture_aspect_ratio,
}
#[test]
fn bindgen_test_layout_di_cta_video_format() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_video_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_video_format>(),
        64usize,
        concat!("Size of: ", stringify!(di_cta_video_format))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_video_format>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_video_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_active) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_active) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_front) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_front)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_front) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_front)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_sync) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_sync) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_back) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_back)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_back) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_back)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_sync_polarity) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_sync_polarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_sync_polarity) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_sync_polarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_clock_hz) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(pixel_clock_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_aspect_ratio) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(picture_aspect_ratio)
        )
    );
}
extern "C" {
    #[doc = " Get a CTA-861 video format from a VIC.\n\n Returns NULL if the VIC is unknown."]
    pub fn di_cta_video_format_from_vic(vic: u8) -> *const di_cta_video_format;
}
#[doc = " EDID CTA-861 extension block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_edid_cta {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the CTA extension revision (also referred to as \"version\" by the\n specification)."]
    pub fn di_edid_cta_get_revision(cta: *const di_edid_cta) -> ::std::os::raw::c_int;
}
#[doc = " Miscellaneous EDID CTA flags, defined in section 7.3.3.\n\n For CTA revision 1, all of the fields are zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_edid_cta_flags {
    pub it_underscan: bool,
    pub basic_audio: bool,
    pub ycc444: bool,
    pub ycc422: bool,
    pub native_dtds: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_di_edid_cta_flags() {
    const UNINIT: ::std::mem::MaybeUninit<di_edid_cta_flags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_edid_cta_flags>(),
        8usize,
        concat!("Size of: ", stringify!(di_edid_cta_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<di_edid_cta_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(di_edid_cta_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_underscan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(it_underscan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic_audio) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(basic_audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycc444) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(ycc444)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycc422) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(ycc422)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_dtds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(native_dtds)
        )
    );
}
extern "C" {
    #[doc = " Get miscellaneous CTA flags."]
    pub fn di_edid_cta_get_flags(cta: *const di_edid_cta) -> *const di_edid_cta_flags;
}
#[doc = " CTA data block, defined in section 7.4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_data_block {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get CTA data blocks.\n\n The returned array is NULL-terminated."]
    pub fn di_edid_cta_get_data_blocks(cta: *const di_edid_cta) -> *const *const di_cta_data_block;
}
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_AUDIO: di_cta_data_block_tag = 1;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO: di_cta_data_block_tag = 2;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_SPEAKER_ALLOC: di_cta_data_block_tag = 3;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VESA_DISPLAY_TRANSFER_CHARACTERISTIC:
    di_cta_data_block_tag = 4;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO_FORMAT: di_cta_data_block_tag = 5;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO_CAP: di_cta_data_block_tag = 6;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VESA_DISPLAY_DEVICE: di_cta_data_block_tag = 7;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_COLORIMETRY: di_cta_data_block_tag = 8;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDR_STATIC_METADATA: di_cta_data_block_tag = 9;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDR_DYNAMIC_METADATA: di_cta_data_block_tag = 10;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_NATIVE_VIDEO_RESOLUTION: di_cta_data_block_tag =
    11;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO_FORMAT_PREF: di_cta_data_block_tag = 12;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_YCBCR420: di_cta_data_block_tag = 13;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_YCBCR420_CAP_MAP: di_cta_data_block_tag = 14;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDMI_AUDIO: di_cta_data_block_tag = 15;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_ROOM_CONFIG: di_cta_data_block_tag = 16;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_SPEAKER_LOCATION: di_cta_data_block_tag = 17;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_INFOFRAME: di_cta_data_block_tag = 18;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_DISPLAYID_VIDEO_TIMING_VII:
    di_cta_data_block_tag = 19;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_DISPLAYID_VIDEO_TIMING_VIII:
    di_cta_data_block_tag = 20;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_DISPLAYID_VIDEO_TIMING_X: di_cta_data_block_tag =
    21;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDMI_EDID_EXT_OVERRIDE: di_cta_data_block_tag =
    22;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDMI_SINK_CAP: di_cta_data_block_tag = 23;
#[doc = " CTA data block tag.\n\n Note, the enum values don't match the specification."]
pub type di_cta_data_block_tag = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get the tag of the CTA data block."]
    pub fn di_cta_data_block_get_tag(block: *const di_cta_data_block) -> di_cta_data_block_tag;
}
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_LPCM: di_cta_audio_format = 1;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_AC3: di_cta_audio_format = 2;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG1: di_cta_audio_format = 3;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MP3: di_cta_audio_format = 4;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG2: di_cta_audio_format = 5;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_AAC_LC: di_cta_audio_format = 6;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DTS: di_cta_audio_format = 7;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_ATRAC: di_cta_audio_format = 8;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_ONE_BIT_AUDIO: di_cta_audio_format = 9;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_ENHANCED_AC3: di_cta_audio_format = 10;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DTS_HD: di_cta_audio_format = 11;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MAT: di_cta_audio_format = 12;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DST: di_cta_audio_format = 13;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_WMA_PRO: di_cta_audio_format = 14;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_HE_AAC: di_cta_audio_format = 15;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_HE_AAC_V2: di_cta_audio_format = 16;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_AAC_LC: di_cta_audio_format = 17;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DRA: di_cta_audio_format = 18;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_HE_AAC_MPEG_SURROUND: di_cta_audio_format =
    19;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_AAC_LC_MPEG_SURROUND: di_cta_audio_format =
    20;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEGH_3D: di_cta_audio_format = 21;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_AC4: di_cta_audio_format = 22;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_LPCM_3D: di_cta_audio_format = 23;
#[doc = " Audio formats, defined in tables 37 and 39.\n\n Note, the enum values don't match the specification."]
pub type di_cta_audio_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_sample_rates {
    pub has_192_khz: bool,
    pub has_176_4_khz: bool,
    pub has_96_khz: bool,
    pub has_88_2_khz: bool,
    pub has_48_khz: bool,
    pub has_44_1_khz: bool,
    pub has_32_khz: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_sample_rates() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_sample_rates> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_sample_rates>(),
        7usize,
        concat!("Size of: ", stringify!(di_cta_sad_sample_rates))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_sample_rates>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_sample_rates))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_192_khz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_192_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_176_4_khz) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_176_4_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_96_khz) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_96_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_88_2_khz) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_88_2_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_48_khz) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_48_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_44_1_khz) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_44_1_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_32_khz) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_32_khz)
        )
    );
}
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_UNSPECIFIED:
    di_cta_sad_mpegh_3d_level = 0;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_1: di_cta_sad_mpegh_3d_level = 1;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_2: di_cta_sad_mpegh_3d_level = 2;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_3: di_cta_sad_mpegh_3d_level = 3;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_4: di_cta_sad_mpegh_3d_level = 4;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_5: di_cta_sad_mpegh_3d_level = 5;
pub type di_cta_sad_mpegh_3d_level = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpegh_3d {
    pub level: di_cta_sad_mpegh_3d_level,
    pub low_complexity_profile: bool,
    pub baseline_profile: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpegh_3d() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpegh_3d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpegh_3d>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpegh_3d))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpegh_3d>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpegh_3d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpegh_3d),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_complexity_profile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpegh_3d),
            "::",
            stringify!(low_complexity_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseline_profile) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpegh_3d),
            "::",
            stringify!(baseline_profile)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpeg_aac {
    pub has_frame_length_960: bool,
    pub has_frame_length_1024: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpeg_aac() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpeg_aac> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpeg_aac>(),
        2usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpeg_aac))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpeg_aac>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpeg_aac))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_frame_length_960) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_aac),
            "::",
            stringify!(has_frame_length_960)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_frame_length_1024) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_aac),
            "::",
            stringify!(has_frame_length_1024)
        )
    );
}
pub const di_cta_sad_mpeg_surround_signaling_DI_CTA_SAD_MPEG_SURROUND_SIGNALING_IMPLICIT:
    di_cta_sad_mpeg_surround_signaling = 0;
pub const di_cta_sad_mpeg_surround_signaling_DI_CTA_SAD_MPEG_SURROUND_SIGNALING_IMPLICIT_AND_EXPLICIT : di_cta_sad_mpeg_surround_signaling = 1 ;
pub type di_cta_sad_mpeg_surround_signaling = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpeg_surround {
    pub signaling: di_cta_sad_mpeg_surround_signaling,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpeg_surround() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpeg_surround> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpeg_surround>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpeg_surround))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpeg_surround>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpeg_surround))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signaling) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_surround),
            "::",
            stringify!(signaling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpeg_aac_le {
    pub supports_multichannel_sound: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpeg_aac_le() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpeg_aac_le> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpeg_aac_le>(),
        1usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpeg_aac_le))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpeg_aac_le>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpeg_aac_le))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_multichannel_sound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_aac_le),
            "::",
            stringify!(supports_multichannel_sound)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_lpcm {
    pub has_sample_size_24_bits: bool,
    pub has_sample_size_20_bits: bool,
    pub has_sample_size_16_bits: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_lpcm() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_lpcm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_lpcm>(),
        3usize,
        concat!("Size of: ", stringify!(di_cta_sad_lpcm))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_lpcm>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_lpcm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sample_size_24_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_lpcm),
            "::",
            stringify!(has_sample_size_24_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sample_size_20_bits) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_lpcm),
            "::",
            stringify!(has_sample_size_20_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sample_size_16_bits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_lpcm),
            "::",
            stringify!(has_sample_size_16_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_enhanced_ac3 {
    pub supports_joint_object_coding: bool,
    pub supports_joint_object_coding_ACMOD28: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_enhanced_ac3() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_enhanced_ac3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_enhanced_ac3>(),
        2usize,
        concat!("Size of: ", stringify!(di_cta_sad_enhanced_ac3))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_enhanced_ac3>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_enhanced_ac3))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_joint_object_coding) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_enhanced_ac3),
            "::",
            stringify!(supports_joint_object_coding)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_joint_object_coding_ACMOD28) as usize
                - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_enhanced_ac3),
            "::",
            stringify!(supports_joint_object_coding_ACMOD28)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mat {
    pub supports_object_audio_and_channel_based: bool,
    pub requires_hash_calculation: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mat() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mat>(),
        2usize,
        concat!("Size of: ", stringify!(di_cta_sad_mat))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mat>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mat))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_object_audio_and_channel_based) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mat),
            "::",
            stringify!(supports_object_audio_and_channel_based)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requires_hash_calculation) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mat),
            "::",
            stringify!(requires_hash_calculation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_wma_pro {
    pub profile: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_di_cta_sad_wma_pro() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_wma_pro> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_wma_pro>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_sad_wma_pro))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_wma_pro>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_sad_wma_pro))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_wma_pro),
            "::",
            stringify!(profile)
        )
    );
}
#[doc = " A CTA short audio descriptor (SAD), defined in section 7.5.2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad {
    pub format: di_cta_audio_format,
    pub max_channels: i32,
    pub supported_sample_rates: *const di_cta_sad_sample_rates,
    pub max_bitrate_kbs: i32,
    pub lpcm: *const di_cta_sad_lpcm,
    pub mpegh_3d: *const di_cta_sad_mpegh_3d,
    pub mpeg_aac: *const di_cta_sad_mpeg_aac,
    pub mpeg_surround: *const di_cta_sad_mpeg_surround,
    pub mpeg_aac_le: *const di_cta_sad_mpeg_aac_le,
    pub enhanced_ac3: *const di_cta_sad_enhanced_ac3,
    pub mat: *const di_cta_sad_mat,
    pub wma_pro: *const di_cta_sad_wma_pro,
}
#[test]
fn bindgen_test_layout_di_cta_sad() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad>(),
        88usize,
        concat!("Size of: ", stringify!(di_cta_sad))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_sad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(max_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_sample_rates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(supported_sample_rates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bitrate_kbs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(max_bitrate_kbs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpcm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(lpcm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpegh_3d) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpegh_3d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg_aac) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpeg_aac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg_surround) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpeg_surround)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg_aac_le) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpeg_aac_le)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enhanced_ac3) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(enhanced_ac3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mat) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wma_pro) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(wma_pro)
        )
    );
}
extern "C" {
    #[doc = " Get an array of short audio descriptors from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_AUDIO.\n\n The returned array is NULL-terminated."]
    pub fn di_cta_data_block_get_sads(
        data_block: *const di_cta_data_block,
    ) -> *const *const di_cta_sad;
}
#[doc = " Speaker allocation data block (SADB), defined in section 7.5.3.\n\n This block indicates which speakers are present. See figure 6 for the meaning\n of the fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_speaker_alloc_block {
    pub flw_frw: bool,
    pub flc_frc: bool,
    pub bc: bool,
    pub bl_br: bool,
    pub fc: bool,
    pub lfe1: bool,
    pub fl_fr: bool,
    pub tpsil_tpsir: bool,
    pub sil_sir: bool,
    pub tpbc: bool,
    pub lfe2: bool,
    pub ls_rs: bool,
    pub tpfc: bool,
    pub tpc: bool,
    pub tpfl_tpfr: bool,
    pub btfl_btfr: bool,
    pub btfc: bool,
    pub tpbl_tpbr: bool,
}
#[test]
fn bindgen_test_layout_di_cta_speaker_alloc_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_speaker_alloc_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_speaker_alloc_block>(),
        18usize,
        concat!("Size of: ", stringify!(di_cta_speaker_alloc_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_speaker_alloc_block>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_speaker_alloc_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flw_frw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(flw_frw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flc_frc) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(flc_frc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(bc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl_br) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(bl_br)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lfe1) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(lfe1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fl_fr) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(fl_fr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpsil_tpsir) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(tpsil_tpsir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sil_sir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(sil_sir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpbc) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(tpbc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lfe2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(lfe2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ls_rs) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(ls_rs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpfc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(tpfc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpc) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(tpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpfl_tpfr) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(tpfl_tpfr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btfl_btfr) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(btfl_btfr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btfc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(btfc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpbl_tpbr) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(tpbl_tpbr)
        )
    );
}
extern "C" {
    #[doc = " Get the speaker allocation from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_SPEAKER_ALLOC."]
    pub fn di_cta_data_block_get_speaker_alloc(
        block: *const di_cta_data_block,
    ) -> *const di_cta_speaker_alloc_block;
}
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_UNKNOWN_OVER_UNDERSCAN:
    di_cta_video_cap_over_underscan = 0;
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_ALWAYS_OVERSCAN:
    di_cta_video_cap_over_underscan = 1;
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_ALWAYS_UNDERSCAN:
    di_cta_video_cap_over_underscan = 2;
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_BOTH_OVER_UNDERSCAN:
    di_cta_video_cap_over_underscan = 3;
#[doc = " Over- and underscan capability."]
pub type di_cta_video_cap_over_underscan = ::std::os::raw::c_uint;
#[doc = " Video capability data block (VCDB), defined in section 7.5.6."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_video_cap_block {
    pub selectable_ycc_quantization_range: bool,
    pub selectable_rgb_quantization_range: bool,
    pub pt_over_underscan: di_cta_video_cap_over_underscan,
    pub it_over_underscan: di_cta_video_cap_over_underscan,
    pub ce_over_underscan: di_cta_video_cap_over_underscan,
}
#[test]
fn bindgen_test_layout_di_cta_video_cap_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_video_cap_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_video_cap_block>(),
        16usize,
        concat!("Size of: ", stringify!(di_cta_video_cap_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_video_cap_block>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_video_cap_block))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).selectable_ycc_quantization_range) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(selectable_ycc_quantization_range)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).selectable_rgb_quantization_range) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(selectable_rgb_quantization_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pt_over_underscan) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(pt_over_underscan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_over_underscan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(it_over_underscan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ce_over_underscan) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(ce_over_underscan)
        )
    );
}
extern "C" {
    #[doc = " Get the video capabilities from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_VIDEO_CAP."]
    pub fn di_cta_data_block_get_video_cap(
        block: *const di_cta_data_block,
    ) -> *const di_cta_video_cap_block;
}
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_VGA:
    di_cta_vesa_dddb_interface_type = 0;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_NAVI_V:
    di_cta_vesa_dddb_interface_type = 1;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_NAVI_D:
    di_cta_vesa_dddb_interface_type = 2;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_LVDS:
    di_cta_vesa_dddb_interface_type = 3;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_RSDS:
    di_cta_vesa_dddb_interface_type = 4;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_DVI_D:
    di_cta_vesa_dddb_interface_type = 5;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_DVI_I_ANALOG:
    di_cta_vesa_dddb_interface_type = 6;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_DVI_I_DIGITAL:
    di_cta_vesa_dddb_interface_type = 7;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_HDMI_A:
    di_cta_vesa_dddb_interface_type = 8;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_HDMI_B:
    di_cta_vesa_dddb_interface_type = 9;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_MDDI:
    di_cta_vesa_dddb_interface_type = 10;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_DISPLAYPORT:
    di_cta_vesa_dddb_interface_type = 11;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_IEEE_1394:
    di_cta_vesa_dddb_interface_type = 12;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_M1_ANALOG:
    di_cta_vesa_dddb_interface_type = 13;
pub const di_cta_vesa_dddb_interface_type_DI_CTA_VESA_DDDB_INTERFACE_M1_DIGITAL:
    di_cta_vesa_dddb_interface_type = 14;
#[doc = " Interface types, defined in VESA DDDB section 2.3.1 and 2.3.2.\n\n Note, the enum values don't match the specification."]
pub type di_cta_vesa_dddb_interface_type = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_content_protection_DI_CTA_VESA_DDDB_CONTENT_PROTECTION_NONE:
    di_cta_vesa_dddb_content_protection = 0;
pub const di_cta_vesa_dddb_content_protection_DI_CTA_VESA_DDDB_CONTENT_PROTECTION_HDCP:
    di_cta_vesa_dddb_content_protection = 1;
pub const di_cta_vesa_dddb_content_protection_DI_CTA_VESA_DDDB_CONTENT_PROTECTION_DTCP:
    di_cta_vesa_dddb_content_protection = 2;
pub const di_cta_vesa_dddb_content_protection_DI_CTA_VESA_DDDB_CONTENT_PROTECTION_DPCP:
    di_cta_vesa_dddb_content_protection = 3;
pub type di_cta_vesa_dddb_content_protection = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_default_orientation_DI_CTA_VESA_DDDB_DEFAULT_ORIENTATION_LANDSCAPE:
    di_cta_vesa_dddb_default_orientation = 0;
pub const di_cta_vesa_dddb_default_orientation_DI_CTA_VESA_DDDB_DEFAULT_ORIENTATION_PORTAIT:
    di_cta_vesa_dddb_default_orientation = 1;
pub const di_cta_vesa_dddb_default_orientation_DI_CTA_VESA_DDDB_DEFAULT_ORIENTATION_UNFIXED:
    di_cta_vesa_dddb_default_orientation = 2;
pub const di_cta_vesa_dddb_default_orientation_DI_CTA_VESA_DDDB_DEFAULT_ORIENTATION_UNDEFINED:
    di_cta_vesa_dddb_default_orientation = 3;
pub type di_cta_vesa_dddb_default_orientation = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_rotation_cap_DI_CTA_VESA_DDDB_ROTATION_CAP_NONE:
    di_cta_vesa_dddb_rotation_cap = 0;
pub const di_cta_vesa_dddb_rotation_cap_DI_CTA_VESA_DDDB_ROTATION_CAP_90DEG_CLOCKWISE:
    di_cta_vesa_dddb_rotation_cap = 1;
pub const di_cta_vesa_dddb_rotation_cap_DI_CTA_VESA_DDDB_ROTATION_CAP_90DEG_COUNTERCLOCKWISE:
    di_cta_vesa_dddb_rotation_cap = 2;
pub const di_cta_vesa_dddb_rotation_cap_DI_CTA_VESA_DDDB_ROTATION_CAP_90DEG_EITHER:
    di_cta_vesa_dddb_rotation_cap = 3;
pub type di_cta_vesa_dddb_rotation_cap = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_zero_pixel_location_DI_CTA_VESA_DDDB_ZERO_PIXEL_UPPER_LEFT:
    di_cta_vesa_dddb_zero_pixel_location = 0;
pub const di_cta_vesa_dddb_zero_pixel_location_DI_CTA_VESA_DDDB_ZERO_PIXEL_UPPER_RIGHT:
    di_cta_vesa_dddb_zero_pixel_location = 1;
pub const di_cta_vesa_dddb_zero_pixel_location_DI_CTA_VESA_DDDB_ZERO_PIXEL_LOWER_LEFT:
    di_cta_vesa_dddb_zero_pixel_location = 2;
pub const di_cta_vesa_dddb_zero_pixel_location_DI_CTA_VESA_DDDB_ZERO_PIXEL_LOWER_RIGHT:
    di_cta_vesa_dddb_zero_pixel_location = 3;
pub type di_cta_vesa_dddb_zero_pixel_location = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_scan_direction_DI_CTA_VESA_DDDB_SCAN_DIRECTION_UNDEFINED:
    di_cta_vesa_dddb_scan_direction = 0;
pub const di_cta_vesa_dddb_scan_direction_DI_CTA_VESA_DDDB_SCAN_DIRECTION_FAST_LONG_SLOW_SHORT:
    di_cta_vesa_dddb_scan_direction = 1;
pub const di_cta_vesa_dddb_scan_direction_DI_CTA_VESA_DDDB_SCAN_DIRECTION_FAST_SHORT_SLOW_LONG:
    di_cta_vesa_dddb_scan_direction = 2;
pub type di_cta_vesa_dddb_scan_direction = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_UNDEFINED:
    di_cta_vesa_dddb_subpixel_layout = 0;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_RGB_VERT:
    di_cta_vesa_dddb_subpixel_layout = 1;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_RGB_HORIZ:
    di_cta_vesa_dddb_subpixel_layout = 2;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_EDID_CHROM_VERT:
    di_cta_vesa_dddb_subpixel_layout = 3;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_EDID_CHROM_HORIZ:
    di_cta_vesa_dddb_subpixel_layout = 4;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_QUAD_RGGB:
    di_cta_vesa_dddb_subpixel_layout = 5;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_QUAD_GBRG:
    di_cta_vesa_dddb_subpixel_layout = 6;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_DELTA_RGB:
    di_cta_vesa_dddb_subpixel_layout = 7;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_MOSAIC:
    di_cta_vesa_dddb_subpixel_layout = 8;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_QUAD_ANY:
    di_cta_vesa_dddb_subpixel_layout = 9;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_FIVE:
    di_cta_vesa_dddb_subpixel_layout = 10;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_SIX:
    di_cta_vesa_dddb_subpixel_layout = 11;
pub const di_cta_vesa_dddb_subpixel_layout_DI_CTA_VESA_DDDB_SUBPIXEL_CLAIRVOYANTE_PENTILE:
    di_cta_vesa_dddb_subpixel_layout = 12;
#[doc = " Subpixel layout, defined in VESA DDDB section 2.9.\n\n For layouts with more than 3 subpixels, the color coordinates of the\n additional subpixels are defined in the additional primary chromaticities."]
pub type di_cta_vesa_dddb_subpixel_layout = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_dithering_type_DI_CTA_VESA_DDDB_DITHERING_NONE:
    di_cta_vesa_dddb_dithering_type = 0;
pub const di_cta_vesa_dddb_dithering_type_DI_CTA_VESA_DDDB_DITHERING_SPACIAL:
    di_cta_vesa_dddb_dithering_type = 1;
pub const di_cta_vesa_dddb_dithering_type_DI_CTA_VESA_DDDB_DITHERING_TEMPORAL:
    di_cta_vesa_dddb_dithering_type = 2;
pub const di_cta_vesa_dddb_dithering_type_DI_CTA_VESA_DDDB_DITHERING_SPATIAL_AND_TEMPORAL:
    di_cta_vesa_dddb_dithering_type = 3;
pub type di_cta_vesa_dddb_dithering_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vesa_dddb_additional_primary_chromaticity {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_di_cta_vesa_dddb_additional_primary_chromaticity() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_vesa_dddb_additional_primary_chromaticity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vesa_dddb_additional_primary_chromaticity>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_vesa_dddb_additional_primary_chromaticity)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vesa_dddb_additional_primary_chromaticity>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_vesa_dddb_additional_primary_chromaticity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb_additional_primary_chromaticity),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb_additional_primary_chromaticity),
            "::",
            stringify!(y)
        )
    );
}
pub const di_cta_vesa_dddb_frame_rate_conversion_DI_CTA_VESA_DDDB_FRAME_RATE_CONVERSION_NONE:
    di_cta_vesa_dddb_frame_rate_conversion = 0;
pub const di_cta_vesa_dddb_frame_rate_conversion_DI_CTA_VESA_DDDB_FRAME_RATE_CONVERSION_SINGLE_BUFFERING : di_cta_vesa_dddb_frame_rate_conversion = 1 ;
pub const di_cta_vesa_dddb_frame_rate_conversion_DI_CTA_VESA_DDDB_FRAME_RATE_CONVERSION_DOUBLE_BUFFERING : di_cta_vesa_dddb_frame_rate_conversion = 2 ;
pub const di_cta_vesa_dddb_frame_rate_conversion_DI_CTA_VESA_DDDB_FRAME_RATE_CONVERSION_ADVANCED:
    di_cta_vesa_dddb_frame_rate_conversion = 3;
pub type di_cta_vesa_dddb_frame_rate_conversion = ::std::os::raw::c_uint;
pub const di_cta_vesa_dddb_resp_time_transition_DI_CTA_VESA_DDDB_RESP_TIME_BLACK_TO_WHITE:
    di_cta_vesa_dddb_resp_time_transition = 0;
pub const di_cta_vesa_dddb_resp_time_transition_DI_CTA_VESA_DDDB_RESP_TIME_WHITE_TO_BLACK:
    di_cta_vesa_dddb_resp_time_transition = 1;
pub type di_cta_vesa_dddb_resp_time_transition = ::std::os::raw::c_uint;
#[doc = " VESA Display Device Data Block (DDDB), defined in VESA Display Device Data\n Block (DDDB) Standard version 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vesa_dddb {
    pub interface_type: di_cta_vesa_dddb_interface_type,
    pub num_channels: i32,
    pub interface_version: i32,
    pub interface_release: i32,
    pub content_protection: di_cta_vesa_dddb_content_protection,
    pub min_clock_freq_mhz: i32,
    pub max_clock_freq_mhz: i32,
    pub native_horiz_pixels: i32,
    pub native_vert_pixels: i32,
    pub aspect_ratio: f32,
    pub default_orientation: di_cta_vesa_dddb_default_orientation,
    pub rotation_cap: di_cta_vesa_dddb_rotation_cap,
    pub zero_pixel_location: di_cta_vesa_dddb_zero_pixel_location,
    pub scan_direction: di_cta_vesa_dddb_scan_direction,
    pub subpixel_layout: di_cta_vesa_dddb_subpixel_layout,
    pub horiz_pitch_mm: f32,
    pub vert_pitch_mm: f32,
    pub dithering_type: di_cta_vesa_dddb_dithering_type,
    pub direct_drive: bool,
    pub overdrive_not_recommended: bool,
    pub deinterlacing: bool,
    pub audio_support: bool,
    pub separate_audio_inputs: bool,
    pub audio_input_override: bool,
    pub audio_delay_provided: bool,
    pub audio_delay_ms: i32,
    pub frame_rate_conversion: di_cta_vesa_dddb_frame_rate_conversion,
    pub frame_rate_range_hz: i32,
    pub frame_rate_native_hz: i32,
    pub bit_depth_interface: i32,
    pub bit_depth_display: i32,
    pub additional_primary_chromaticities_len: usize,
    pub additional_primary_chromaticities:
        [di_cta_vesa_dddb_additional_primary_chromaticity; 3usize],
    pub resp_time_transition: di_cta_vesa_dddb_resp_time_transition,
    pub resp_time_ms: i32,
    pub overscan_horiz_pct: i32,
    pub overscan_vert_pct: i32,
}
#[test]
fn bindgen_test_layout_di_cta_vesa_dddb() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_vesa_dddb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vesa_dddb>(),
        152usize,
        concat!("Size of: ", stringify!(di_cta_vesa_dddb))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vesa_dddb>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_vesa_dddb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(interface_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(interface_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_release) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(interface_release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_protection) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(content_protection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_clock_freq_mhz) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(min_clock_freq_mhz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_clock_freq_mhz) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(max_clock_freq_mhz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_horiz_pixels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(native_horiz_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_vert_pixels) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(native_vert_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect_ratio) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_orientation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(default_orientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation_cap) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(rotation_cap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_pixel_location) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(zero_pixel_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scan_direction) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(scan_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subpixel_layout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(subpixel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horiz_pitch_mm) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(horiz_pitch_mm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vert_pitch_mm) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(vert_pitch_mm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dithering_type) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(dithering_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direct_drive) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(direct_drive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overdrive_not_recommended) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(overdrive_not_recommended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deinterlacing) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(deinterlacing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_support) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(audio_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).separate_audio_inputs) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(separate_audio_inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_input_override) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(audio_input_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_delay_provided) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(audio_delay_provided)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_delay_ms) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(audio_delay_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate_conversion) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(frame_rate_conversion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate_range_hz) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(frame_rate_range_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate_native_hz) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(frame_rate_native_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_interface) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(bit_depth_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_display) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(bit_depth_display)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).additional_primary_chromaticities_len) as usize
                - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(additional_primary_chromaticities_len)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).additional_primary_chromaticities) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(additional_primary_chromaticities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_time_transition) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(resp_time_transition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_time_ms) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(resp_time_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overscan_horiz_pct) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(overscan_horiz_pct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overscan_vert_pct) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_dddb),
            "::",
            stringify!(overscan_vert_pct)
        )
    );
}
extern "C" {
    #[doc = " Get the VESA Display Device Data Block (DDDB) from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_VESA_DISPLAY_DEVICE."]
    pub fn di_cta_data_block_get_vesa_dddb(
        block: *const di_cta_data_block,
    ) -> *const di_cta_vesa_dddb;
}
#[doc = " CTA colorimetry data block, defined in section 7.5.5."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_colorimetry_block {
    pub xvycc_601: bool,
    pub xvycc_709: bool,
    pub sycc_601: bool,
    pub opycc_601: bool,
    pub oprgb: bool,
    pub bt2020_cycc: bool,
    pub bt2020_ycc: bool,
    pub bt2020_rgb: bool,
    pub st2113_rgb: bool,
    pub ictcp: bool,
}
#[test]
fn bindgen_test_layout_di_cta_colorimetry_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_colorimetry_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_colorimetry_block>(),
        10usize,
        concat!("Size of: ", stringify!(di_cta_colorimetry_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_colorimetry_block>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_colorimetry_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xvycc_601) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(xvycc_601)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xvycc_709) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(xvycc_709)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sycc_601) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(sycc_601)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opycc_601) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(opycc_601)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oprgb) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(oprgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt2020_cycc) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(bt2020_cycc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt2020_ycc) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(bt2020_ycc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt2020_rgb) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(bt2020_rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st2113_rgb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(st2113_rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ictcp) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(ictcp)
        )
    );
}
extern "C" {
    #[doc = " Get the colorimetry data from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_COLORIMETRY."]
    pub fn di_cta_data_block_get_colorimetry(
        block: *const di_cta_data_block,
    ) -> *const di_cta_colorimetry_block;
}
#[doc = " Supported Electro-Optical Transfer Functions for a CTA HDR static metadata\n block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_static_metadata_block_eotfs {
    pub traditional_sdr: bool,
    pub traditional_hdr: bool,
    pub pq: bool,
    pub hlg: bool,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_static_metadata_block_eotfs() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_static_metadata_block_eotfs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_static_metadata_block_eotfs>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_hdr_static_metadata_block_eotfs)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_static_metadata_block_eotfs>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_static_metadata_block_eotfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traditional_sdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block_eotfs),
            "::",
            stringify!(traditional_sdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traditional_hdr) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block_eotfs),
            "::",
            stringify!(traditional_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pq) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block_eotfs),
            "::",
            stringify!(pq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hlg) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block_eotfs),
            "::",
            stringify!(hlg)
        )
    );
}
#[doc = " Supported static metadata descriptors for a CTA HDR static metadata block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_static_metadata_block_descriptors {
    pub type1: bool,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_static_metadata_block_descriptors() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_static_metadata_block_descriptors> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_static_metadata_block_descriptors>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_hdr_static_metadata_block_descriptors)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_static_metadata_block_descriptors>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_static_metadata_block_descriptors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block_descriptors),
            "::",
            stringify!(type1)
        )
    );
}
#[doc = " CTA HDR static metadata block, defined in section 7.5.13."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_static_metadata_block {
    pub desired_content_max_luminance: f32,
    pub desired_content_max_frame_avg_luminance: f32,
    pub desired_content_min_luminance: f32,
    pub eotfs: *const di_cta_hdr_static_metadata_block_eotfs,
    pub descriptors: *const di_cta_hdr_static_metadata_block_descriptors,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_static_metadata_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_static_metadata_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_static_metadata_block>(),
        32usize,
        concat!("Size of: ", stringify!(di_cta_hdr_static_metadata_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_static_metadata_block>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_static_metadata_block)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_luminance) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(desired_content_max_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_frame_avg_luminance) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(desired_content_max_frame_avg_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_min_luminance) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(desired_content_min_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eotfs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(eotfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(descriptors)
        )
    );
}
extern "C" {
    #[doc = " Get the HDR static metadata from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_HDR_STATIC_METADATA."]
    pub fn di_cta_data_block_get_hdr_static_metadata(
        block: *const di_cta_data_block,
    ) -> *const di_cta_hdr_static_metadata_block;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_block_type1 {
    pub type_1_hdr_metadata_version: u8,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_block_type1() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_block_type1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_block_type1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_block_type1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_1_hdr_metadata_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type1),
            "::",
            stringify!(type_1_hdr_metadata_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_block_type2 {
    pub ts_103_433_spec_version: u8,
    pub ts_103_433_1_capable: bool,
    pub ts_103_433_2_capable: bool,
    pub ts_103_433_3_capable: bool,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_block_type2() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_block_type2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_block_type2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_block_type2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_spec_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type2),
            "::",
            stringify!(ts_103_433_spec_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_1_capable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type2),
            "::",
            stringify!(ts_103_433_1_capable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_2_capable) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type2),
            "::",
            stringify!(ts_103_433_2_capable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_3_capable) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type2),
            "::",
            stringify!(ts_103_433_3_capable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_block_type3 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_block_type4 {
    pub type_4_hdr_metadata_version: u8,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_block_type4() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_block_type4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_block_type4>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_block_type4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_4_hdr_metadata_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type4),
            "::",
            stringify!(type_4_hdr_metadata_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_block_type256 {
    pub graphics_overlay_flag_version: u8,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_block_type256() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_block_type256> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_block_type256>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type256)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_block_type256>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type256)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).graphics_overlay_flag_version) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block_type256),
            "::",
            stringify!(graphics_overlay_flag_version)
        )
    );
}
#[doc = " CTA HDR dynamic metadata block, defined in section 7.5.14."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_block {
    pub type1: *const di_cta_hdr_dynamic_metadata_block_type1,
    pub type2: *const di_cta_hdr_dynamic_metadata_block_type2,
    pub type3: *const di_cta_hdr_dynamic_metadata_block_type3,
    pub type4: *const di_cta_hdr_dynamic_metadata_block_type4,
    pub type256: *const di_cta_hdr_dynamic_metadata_block_type256,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_block>(),
        40usize,
        concat!("Size of: ", stringify!(di_cta_hdr_dynamic_metadata_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_block>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type256) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type256)
        )
    );
}
extern "C" {
    #[doc = " Get the HDR dynamic metadata from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_HDR_DYNAMIC_METADATA."]
    pub fn di_cta_data_block_get_hdr_dynamic_metadata(
        block: *const di_cta_data_block,
    ) -> *const di_cta_hdr_dynamic_metadata_block;
}
#[doc = " A Short Video Descriptor (SVD)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_svd {
    pub vic: u8,
    pub native: bool,
}
#[test]
fn bindgen_test_layout_di_cta_svd() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_svd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_svd>(),
        2usize,
        concat!("Size of: ", stringify!(di_cta_svd))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_svd>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_svd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svd),
            "::",
            stringify!(vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svd),
            "::",
            stringify!(native)
        )
    );
}
extern "C" {
    #[doc = " Get an array of short video descriptors from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_VIDEO.\n\n The returned array is NULL-terminated."]
    pub fn di_cta_data_block_get_svds(block: *const di_cta_data_block) -> *const *const di_cta_svd;
}
extern "C" {
    #[doc = " Get an array of short video descriptors which only allow YCbCr 4:2:0 sampling\n mode from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_YCBCR420.\n\n The returned array is NULL-terminated."]
    pub fn di_cta_data_block_get_ycbcr420_svds(
        block: *const di_cta_data_block,
    ) -> *const *const di_cta_svd;
}
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_WHITE : di_cta_vesa_transfer_characteristics_usage = 0 ;
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_RED : di_cta_vesa_transfer_characteristics_usage = 1 ;
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_GREEN : di_cta_vesa_transfer_characteristics_usage = 2 ;
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_BLUE : di_cta_vesa_transfer_characteristics_usage = 3 ;
pub type di_cta_vesa_transfer_characteristics_usage = ::std::os::raw::c_uint;
#[doc = " VESA Display Transfer Characteristic Data Block, defined in VESA Display\n Transfer Characteristics Data Block Standard Version 1.0\n\n Contains 8, 16 or 32 evenly distributed points on the input axis describing\n the normalized relative luminance at that input. The first value includes the\n relative black level luminance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vesa_transfer_characteristics {
    pub usage: di_cta_vesa_transfer_characteristics_usage,
    pub points_len: u8,
    pub points: [f32; 32usize],
}
#[test]
fn bindgen_test_layout_di_cta_vesa_transfer_characteristics() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_vesa_transfer_characteristics> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vesa_transfer_characteristics>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_vesa_transfer_characteristics)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vesa_transfer_characteristics>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_vesa_transfer_characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_transfer_characteristics),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_transfer_characteristics),
            "::",
            stringify!(points_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_transfer_characteristics),
            "::",
            stringify!(points)
        )
    );
}
extern "C" {
    #[doc = " Get the Display Transfer Characteristic from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_VESA_DISPLAY_TRANSFER_CHARACTERISTIC.\n\n Upstream is not aware of any EDID blob containing a Display Transfer\n Characteristic data block.\n If such a blob is found, please share it with upstream!"]
    pub fn di_cta_data_block_get_vesa_transfer_characteristics(
        block: *const di_cta_data_block,
    ) -> *const di_cta_vesa_transfer_characteristics;
}
#[doc = " CTA YCbCr 4:2:0 Capability Map block, defined in section 7.5.11."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_ycbcr420_cap_map {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns true if the SVD in regular Video Data Blocks at index `svd_index`\n supports YCbCr 4:2:0 subsampling."]
    pub fn di_cta_ycbcr420_cap_map_supported(
        cap_map: *const di_cta_ycbcr420_cap_map,
        svd_index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the YCbCr 4:2:0 Capability Map from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_YCBCR420_CAP_MAP."]
    pub fn di_cta_data_block_get_ycbcr420_cap_map(
        block: *const di_cta_data_block,
    ) -> *const di_cta_ycbcr420_cap_map;
}
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_AUXILIARY_VIDEO_INFORMATION:
    di_cta_infoframe_type = 0;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_SOURCE_PRODUCT_DESCRIPTION:
    di_cta_infoframe_type = 1;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_AUDIO: di_cta_infoframe_type = 2;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_MPEG_SOURCE: di_cta_infoframe_type = 3;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_NTSC_VBI: di_cta_infoframe_type = 4;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_DYNAMIC_RANGE_AND_MASTERING:
    di_cta_infoframe_type = 5;
#[doc = " InfoFrame types, defined in table 7.\n\n Note, the enum values don't match the specification."]
pub type di_cta_infoframe_type = ::std::os::raw::c_uint;
#[doc = " CTA InfoFrame descriptor, defined in section 7.5.9."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_infoframe_descriptor {
    pub type_: di_cta_infoframe_type,
}
#[test]
fn bindgen_test_layout_di_cta_infoframe_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_infoframe_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_infoframe_descriptor>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_infoframe_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_infoframe_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_infoframe_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_infoframe_descriptor),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " CTA InfoFrame processing, defined in section 7.5.9."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_infoframe_block {
    pub num_simultaneous_vsifs: ::std::os::raw::c_int,
    pub infoframes: *const *const di_cta_infoframe_descriptor,
}
#[test]
fn bindgen_test_layout_di_cta_infoframe_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_infoframe_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_infoframe_block>(),
        16usize,
        concat!("Size of: ", stringify!(di_cta_infoframe_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_infoframe_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_infoframe_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_simultaneous_vsifs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_infoframe_block),
            "::",
            stringify!(num_simultaneous_vsifs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infoframes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_infoframe_block),
            "::",
            stringify!(infoframes)
        )
    );
}
extern "C" {
    #[doc = " Get the InfoFrame information from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_INFOFRAME."]
    pub fn di_cta_data_block_get_infoframe(
        block: *const di_cta_data_block,
    ) -> *const di_cta_infoframe_block;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_edid_detailed_timing_def {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a list of EDID detailed timing definitions.\n\n The returned array is NULL-terminated."]
    pub fn di_edid_cta_get_detailed_timing_defs(
        cta: *const di_edid_cta,
    ) -> *const *const di_edid_detailed_timing_def;
}
