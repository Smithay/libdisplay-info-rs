/* automatically generated by rust-bindgen 0.68.1 */

pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_4_3:
    di_cta_video_format_picture_aspect_ratio = 0;
pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_16_9:
    di_cta_video_format_picture_aspect_ratio = 1;
pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_64_27 : di_cta_video_format_picture_aspect_ratio = 2 ;
pub const di_cta_video_format_picture_aspect_ratio_DI_CTA_VIDEO_FORMAT_PICTURE_ASPECT_RATIO_256_135 : di_cta_video_format_picture_aspect_ratio = 3 ;
#[doc = " CTA video format picture aspect ratio."]
pub type di_cta_video_format_picture_aspect_ratio = ::std::os::raw::c_uint;
pub const di_cta_video_format_sync_polarity_DI_CTA_VIDEO_FORMAT_SYNC_NEGATIVE:
    di_cta_video_format_sync_polarity = 0;
pub const di_cta_video_format_sync_polarity_DI_CTA_VIDEO_FORMAT_SYNC_POSITIVE:
    di_cta_video_format_sync_polarity = 1;
#[doc = " CTA video format sync pulse polarity."]
pub type di_cta_video_format_sync_polarity = ::std::os::raw::c_uint;
#[doc = " A CTA-861 video format, defined in section 4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_video_format {
    pub vic: u8,
    pub h_active: i32,
    pub v_active: i32,
    pub h_front: i32,
    pub v_front: i32,
    pub h_sync: i32,
    pub v_sync: i32,
    pub h_back: i32,
    pub v_back: i32,
    pub h_sync_polarity: di_cta_video_format_sync_polarity,
    pub v_sync_polarity: di_cta_video_format_sync_polarity,
    pub pixel_clock_hz: i64,
    pub interlaced: bool,
    pub picture_aspect_ratio: di_cta_video_format_picture_aspect_ratio,
}
#[test]
fn bindgen_test_layout_di_cta_video_format() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_video_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_video_format>(),
        64usize,
        concat!("Size of: ", stringify!(di_cta_video_format))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_video_format>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_video_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_active) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_active) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_front) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_front)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_front) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_front)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_sync) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_sync) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_back) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_back)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_back) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_back)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_sync_polarity) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(h_sync_polarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_sync_polarity) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(v_sync_polarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_clock_hz) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(pixel_clock_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_aspect_ratio) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format),
            "::",
            stringify!(picture_aspect_ratio)
        )
    );
}
extern "C" {
    #[doc = " Get a CTA-861 video format from a VIC.\n\n Returns NULL if the VIC is unknown."]
    pub fn di_cta_video_format_from_vic(vic: u8) -> *const di_cta_video_format;
}
#[doc = " A HDMI video format, not to be confused with a CTA-861 video format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdmi_video_format {
    pub vic: u8,
    pub h_active: i32,
    pub v_active: i32,
    pub h_front: i32,
    pub v_front: i32,
    pub h_sync: i32,
    pub v_sync: i32,
    pub h_back: i32,
    pub v_back: i32,
    pub pixel_clock_hz: i64,
}
#[test]
fn bindgen_test_layout_di_cta_hdmi_video_format() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdmi_video_format> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdmi_video_format>(),
        48usize,
        concat!("Size of: ", stringify!(di_cta_hdmi_video_format))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdmi_video_format>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_hdmi_video_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_active) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(h_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_active) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(v_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_front) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(h_front)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_front) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(v_front)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_sync) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(h_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_sync) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(v_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_back) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(h_back)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_back) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(v_back)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_clock_hz) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_video_format),
            "::",
            stringify!(pixel_clock_hz)
        )
    );
}
extern "C" {
    #[doc = " Get a HDMI video format from a HDMI VIC.\n\n Returns NULL if the HDMI VIC is unknown."]
    pub fn di_cta_hdmi_video_format_from_hdmi_vic(hdmi_vic: u8) -> *const di_cta_hdmi_video_format;
}
#[doc = " EDID CTA-861 extension block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_edid_cta {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the CTA extension revision (also referred to as \"version\" by the\n specification)."]
    pub fn di_edid_cta_get_revision(cta: *const di_edid_cta) -> ::std::os::raw::c_int;
}
#[doc = " Miscellaneous EDID CTA flags, defined in section 7.3.3.\n\n For CTA revision 1, all of the fields are zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_edid_cta_flags {
    pub it_underscan: bool,
    pub basic_audio: bool,
    pub ycc444: bool,
    pub ycc422: bool,
    pub native_dtds: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_di_edid_cta_flags() {
    const UNINIT: ::std::mem::MaybeUninit<di_edid_cta_flags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_edid_cta_flags>(),
        8usize,
        concat!("Size of: ", stringify!(di_edid_cta_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<di_edid_cta_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(di_edid_cta_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_underscan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(it_underscan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic_audio) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(basic_audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycc444) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(ycc444)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycc422) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(ycc422)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_dtds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_edid_cta_flags),
            "::",
            stringify!(native_dtds)
        )
    );
}
extern "C" {
    #[doc = " Get miscellaneous CTA flags."]
    pub fn di_edid_cta_get_flags(cta: *const di_edid_cta) -> *const di_edid_cta_flags;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_edid_detailed_timing_def {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a list of EDID detailed timing definitions.\n\n The returned array is NULL-terminated."]
    pub fn di_edid_cta_get_detailed_timing_defs(
        cta: *const di_edid_cta,
    ) -> *const *const di_edid_detailed_timing_def;
}
#[doc = " CTA data block, defined in section 7.4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_data_block {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get CTA data blocks.\n\n The returned array is NULL-terminated."]
    pub fn di_edid_cta_get_data_blocks(cta: *const di_edid_cta) -> *const *const di_cta_data_block;
}
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_AUDIO: di_cta_data_block_tag = 1;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO: di_cta_data_block_tag = 2;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_SPEAKER_ALLOC: di_cta_data_block_tag = 3;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VESA_DISPLAY_TRANSFER_CHARACTERISTIC:
    di_cta_data_block_tag = 4;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO_FORMAT: di_cta_data_block_tag = 5;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO_CAP: di_cta_data_block_tag = 6;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VESA_DISPLAY_DEVICE: di_cta_data_block_tag = 7;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_COLORIMETRY: di_cta_data_block_tag = 8;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDR_STATIC_METADATA: di_cta_data_block_tag = 9;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDR_DYNAMIC_METADATA: di_cta_data_block_tag = 10;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_NATIVE_VIDEO_RESOLUTION: di_cta_data_block_tag =
    11;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VIDEO_FORMAT_PREF: di_cta_data_block_tag = 12;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_YCBCR420: di_cta_data_block_tag = 13;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_YCBCR420_CAP_MAP: di_cta_data_block_tag = 14;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDMI_AUDIO: di_cta_data_block_tag = 15;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_ROOM_CONFIG: di_cta_data_block_tag = 16;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_SPEAKER_LOCATION: di_cta_data_block_tag = 17;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_INFOFRAME: di_cta_data_block_tag = 18;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_DISPLAYID_VIDEO_TIMING_VII:
    di_cta_data_block_tag = 19;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_DISPLAYID_VIDEO_TIMING_VIII:
    di_cta_data_block_tag = 20;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_DISPLAYID_VIDEO_TIMING_X: di_cta_data_block_tag =
    21;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDMI_EDID_EXT_OVERRIDE: di_cta_data_block_tag =
    22;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDMI_SINK_CAP: di_cta_data_block_tag = 23;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VENDOR_HDMI: di_cta_data_block_tag = 24;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_DOLBY_VIDEO: di_cta_data_block_tag = 25;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_HDR10PLUS: di_cta_data_block_tag = 26;
pub const di_cta_data_block_tag_DI_CTA_DATA_BLOCK_VENDOR_HDMI_FORUM: di_cta_data_block_tag = 27;
#[doc = " CTA data block tag.\n\n Note, the enum values don't match the specification."]
pub type di_cta_data_block_tag = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get the tag of the CTA data block."]
    pub fn di_cta_data_block_get_tag(block: *const di_cta_data_block) -> di_cta_data_block_tag;
}
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_LPCM: di_cta_audio_format = 1;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_AC3: di_cta_audio_format = 2;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG1: di_cta_audio_format = 3;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MP3: di_cta_audio_format = 4;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG2: di_cta_audio_format = 5;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_AAC_LC: di_cta_audio_format = 6;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DTS: di_cta_audio_format = 7;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_ATRAC: di_cta_audio_format = 8;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_ONE_BIT_AUDIO: di_cta_audio_format = 9;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_ENHANCED_AC3: di_cta_audio_format = 10;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DTS_HD: di_cta_audio_format = 11;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MAT: di_cta_audio_format = 12;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DST: di_cta_audio_format = 13;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_WMA_PRO: di_cta_audio_format = 14;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_HE_AAC: di_cta_audio_format = 15;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_HE_AAC_V2: di_cta_audio_format = 16;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_AAC_LC: di_cta_audio_format = 17;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_DRA: di_cta_audio_format = 18;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_HE_AAC_MPEG_SURROUND: di_cta_audio_format =
    19;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEG4_AAC_LC_MPEG_SURROUND: di_cta_audio_format =
    20;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_MPEGH_3D: di_cta_audio_format = 21;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_AC4: di_cta_audio_format = 22;
pub const di_cta_audio_format_DI_CTA_AUDIO_FORMAT_LPCM_3D: di_cta_audio_format = 23;
#[doc = " Audio formats, defined in tables 37 and 39.\n\n Note, the enum values don't match the specification."]
pub type di_cta_audio_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_sample_rates {
    pub has_192_khz: bool,
    pub has_176_4_khz: bool,
    pub has_96_khz: bool,
    pub has_88_2_khz: bool,
    pub has_48_khz: bool,
    pub has_44_1_khz: bool,
    pub has_32_khz: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_sample_rates() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_sample_rates> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_sample_rates>(),
        7usize,
        concat!("Size of: ", stringify!(di_cta_sad_sample_rates))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_sample_rates>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_sample_rates))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_192_khz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_192_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_176_4_khz) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_176_4_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_96_khz) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_96_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_88_2_khz) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_88_2_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_48_khz) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_48_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_44_1_khz) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_44_1_khz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_32_khz) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_sample_rates),
            "::",
            stringify!(has_32_khz)
        )
    );
}
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_UNSPECIFIED:
    di_cta_sad_mpegh_3d_level = 0;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_1: di_cta_sad_mpegh_3d_level = 1;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_2: di_cta_sad_mpegh_3d_level = 2;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_3: di_cta_sad_mpegh_3d_level = 3;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_4: di_cta_sad_mpegh_3d_level = 4;
pub const di_cta_sad_mpegh_3d_level_DI_CTA_SAD_MPEGH_3D_LEVEL_5: di_cta_sad_mpegh_3d_level = 5;
pub type di_cta_sad_mpegh_3d_level = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpegh_3d {
    pub level: di_cta_sad_mpegh_3d_level,
    pub low_complexity_profile: bool,
    pub baseline_profile: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpegh_3d() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpegh_3d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpegh_3d>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpegh_3d))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpegh_3d>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpegh_3d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpegh_3d),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_complexity_profile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpegh_3d),
            "::",
            stringify!(low_complexity_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseline_profile) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpegh_3d),
            "::",
            stringify!(baseline_profile)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpeg_aac {
    pub has_frame_length_960: bool,
    pub has_frame_length_1024: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpeg_aac() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpeg_aac> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpeg_aac>(),
        2usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpeg_aac))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpeg_aac>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpeg_aac))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_frame_length_960) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_aac),
            "::",
            stringify!(has_frame_length_960)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_frame_length_1024) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_aac),
            "::",
            stringify!(has_frame_length_1024)
        )
    );
}
pub const di_cta_sad_mpeg_surround_signaling_DI_CTA_SAD_MPEG_SURROUND_SIGNALING_IMPLICIT:
    di_cta_sad_mpeg_surround_signaling = 0;
pub const di_cta_sad_mpeg_surround_signaling_DI_CTA_SAD_MPEG_SURROUND_SIGNALING_IMPLICIT_AND_EXPLICIT : di_cta_sad_mpeg_surround_signaling = 1 ;
pub type di_cta_sad_mpeg_surround_signaling = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpeg_surround {
    pub signaling: di_cta_sad_mpeg_surround_signaling,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpeg_surround() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpeg_surround> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpeg_surround>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpeg_surround))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpeg_surround>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpeg_surround))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signaling) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_surround),
            "::",
            stringify!(signaling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mpeg_aac_le {
    pub supports_multichannel_sound: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mpeg_aac_le() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mpeg_aac_le> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mpeg_aac_le>(),
        1usize,
        concat!("Size of: ", stringify!(di_cta_sad_mpeg_aac_le))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mpeg_aac_le>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mpeg_aac_le))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_multichannel_sound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mpeg_aac_le),
            "::",
            stringify!(supports_multichannel_sound)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_lpcm {
    pub has_sample_size_24_bits: bool,
    pub has_sample_size_20_bits: bool,
    pub has_sample_size_16_bits: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_lpcm() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_lpcm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_lpcm>(),
        3usize,
        concat!("Size of: ", stringify!(di_cta_sad_lpcm))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_lpcm>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_lpcm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sample_size_24_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_lpcm),
            "::",
            stringify!(has_sample_size_24_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sample_size_20_bits) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_lpcm),
            "::",
            stringify!(has_sample_size_20_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sample_size_16_bits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_lpcm),
            "::",
            stringify!(has_sample_size_16_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_enhanced_ac3 {
    pub supports_joint_object_coding: bool,
    pub supports_joint_object_coding_ACMOD28: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_enhanced_ac3() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_enhanced_ac3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_enhanced_ac3>(),
        2usize,
        concat!("Size of: ", stringify!(di_cta_sad_enhanced_ac3))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_enhanced_ac3>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_enhanced_ac3))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_joint_object_coding) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_enhanced_ac3),
            "::",
            stringify!(supports_joint_object_coding)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_joint_object_coding_ACMOD28) as usize
                - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_enhanced_ac3),
            "::",
            stringify!(supports_joint_object_coding_ACMOD28)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_mat {
    pub supports_object_audio_and_channel_based: bool,
    pub requires_hash_calculation: bool,
}
#[test]
fn bindgen_test_layout_di_cta_sad_mat() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_mat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_mat>(),
        2usize,
        concat!("Size of: ", stringify!(di_cta_sad_mat))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_mat>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_sad_mat))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_object_audio_and_channel_based) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mat),
            "::",
            stringify!(supports_object_audio_and_channel_based)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requires_hash_calculation) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_mat),
            "::",
            stringify!(requires_hash_calculation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad_wma_pro {
    pub profile: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_di_cta_sad_wma_pro() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad_wma_pro> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad_wma_pro>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_sad_wma_pro))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad_wma_pro>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_sad_wma_pro))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad_wma_pro),
            "::",
            stringify!(profile)
        )
    );
}
#[doc = " A CTA short audio descriptor (SAD), defined in section 7.5.2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_sad {
    pub format: di_cta_audio_format,
    pub max_channels: i32,
    pub supported_sample_rates: *const di_cta_sad_sample_rates,
    pub max_bitrate_kbs: i32,
    pub lpcm: *const di_cta_sad_lpcm,
    pub mpegh_3d: *const di_cta_sad_mpegh_3d,
    pub mpeg_aac: *const di_cta_sad_mpeg_aac,
    pub mpeg_surround: *const di_cta_sad_mpeg_surround,
    pub mpeg_aac_le: *const di_cta_sad_mpeg_aac_le,
    pub enhanced_ac3: *const di_cta_sad_enhanced_ac3,
    pub mat: *const di_cta_sad_mat,
    pub wma_pro: *const di_cta_sad_wma_pro,
}
#[test]
fn bindgen_test_layout_di_cta_sad() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_sad> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_sad>(),
        88usize,
        concat!("Size of: ", stringify!(di_cta_sad))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_sad>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_sad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(max_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_sample_rates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(supported_sample_rates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bitrate_kbs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(max_bitrate_kbs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpcm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(lpcm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpegh_3d) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpegh_3d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg_aac) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpeg_aac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg_surround) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpeg_surround)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg_aac_le) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mpeg_aac_le)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enhanced_ac3) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(enhanced_ac3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mat) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(mat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wma_pro) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_sad),
            "::",
            stringify!(wma_pro)
        )
    );
}
#[doc = " Audio Data Block, defined in section 7.5.2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_audio_block {
    pub sads: *const *const di_cta_sad,
}
#[test]
fn bindgen_test_layout_di_cta_audio_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_audio_block> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_audio_block>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_audio_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_audio_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_audio_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sads) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_audio_block),
            "::",
            stringify!(sads)
        )
    );
}
extern "C" {
    #[doc = " Get the audio from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_AUDIO."]
    pub fn di_cta_data_block_get_audio(
        data_block: *const di_cta_data_block,
    ) -> *const di_cta_audio_block;
}
#[doc = " Indicates which speakers are present. See figure 6 for the meaning of the\n fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_speaker_allocation {
    pub flw_frw: bool,
    pub flc_frc: bool,
    pub bc: bool,
    pub bl_br: bool,
    pub fc: bool,
    pub lfe1: bool,
    pub fl_fr: bool,
    pub tpsil_tpsir: bool,
    pub sil_sir: bool,
    pub tpbc: bool,
    pub lfe2: bool,
    pub ls_rs: bool,
    pub tpfc: bool,
    pub tpc: bool,
    pub tpfl_tpfr: bool,
    pub btfl_btfr: bool,
    pub btfc: bool,
    pub tpbl_tpbr: bool,
}
#[test]
fn bindgen_test_layout_di_cta_speaker_allocation() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_speaker_allocation> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_speaker_allocation>(),
        18usize,
        concat!("Size of: ", stringify!(di_cta_speaker_allocation))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_speaker_allocation>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_speaker_allocation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flw_frw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(flw_frw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flc_frc) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(flc_frc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(bc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl_br) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(bl_br)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lfe1) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(lfe1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fl_fr) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(fl_fr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpsil_tpsir) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(tpsil_tpsir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sil_sir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(sil_sir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpbc) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(tpbc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lfe2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(lfe2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ls_rs) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(ls_rs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpfc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(tpfc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpc) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(tpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpfl_tpfr) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(tpfl_tpfr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btfl_btfr) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(btfl_btfr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btfc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(btfc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpbl_tpbr) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_allocation),
            "::",
            stringify!(tpbl_tpbr)
        )
    );
}
#[doc = " Speaker allocation data block (SADB), defined in section 7.5.3."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_speaker_alloc_block {
    pub speakers: di_cta_speaker_allocation,
}
#[test]
fn bindgen_test_layout_di_cta_speaker_alloc_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_speaker_alloc_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_speaker_alloc_block>(),
        18usize,
        concat!("Size of: ", stringify!(di_cta_speaker_alloc_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_speaker_alloc_block>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_speaker_alloc_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_alloc_block),
            "::",
            stringify!(speakers)
        )
    );
}
extern "C" {
    #[doc = " Get the speaker allocation from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_SPEAKER_ALLOC."]
    pub fn di_cta_data_block_get_speaker_alloc(
        block: *const di_cta_data_block,
    ) -> *const di_cta_speaker_alloc_block;
}
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_UNKNOWN_OVER_UNDERSCAN:
    di_cta_video_cap_over_underscan = 0;
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_ALWAYS_OVERSCAN:
    di_cta_video_cap_over_underscan = 1;
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_ALWAYS_UNDERSCAN:
    di_cta_video_cap_over_underscan = 2;
pub const di_cta_video_cap_over_underscan_DI_CTA_VIDEO_CAP_BOTH_OVER_UNDERSCAN:
    di_cta_video_cap_over_underscan = 3;
#[doc = " Over- and underscan capability."]
pub type di_cta_video_cap_over_underscan = ::std::os::raw::c_uint;
#[doc = " Video capability data block (VCDB), defined in section 7.5.6."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_video_cap_block {
    pub selectable_ycc_quantization_range: bool,
    pub selectable_rgb_quantization_range: bool,
    pub pt_over_underscan: di_cta_video_cap_over_underscan,
    pub it_over_underscan: di_cta_video_cap_over_underscan,
    pub ce_over_underscan: di_cta_video_cap_over_underscan,
}
#[test]
fn bindgen_test_layout_di_cta_video_cap_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_video_cap_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_video_cap_block>(),
        16usize,
        concat!("Size of: ", stringify!(di_cta_video_cap_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_video_cap_block>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_video_cap_block))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).selectable_ycc_quantization_range) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(selectable_ycc_quantization_range)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).selectable_rgb_quantization_range) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(selectable_rgb_quantization_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pt_over_underscan) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(pt_over_underscan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_over_underscan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(it_over_underscan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ce_over_underscan) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_cap_block),
            "::",
            stringify!(ce_over_underscan)
        )
    );
}
extern "C" {
    #[doc = " Get the video capabilities from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_VIDEO_CAP."]
    pub fn di_cta_data_block_get_video_cap(
        block: *const di_cta_data_block,
    ) -> *const di_cta_video_cap_block;
}
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_VGA:
    di_cta_vesa_display_device_interface_type = 0;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_NAVI_V:
    di_cta_vesa_display_device_interface_type = 1;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_NAVI_D:
    di_cta_vesa_display_device_interface_type = 2;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_LVDS:
    di_cta_vesa_display_device_interface_type = 3;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_RSDS:
    di_cta_vesa_display_device_interface_type = 4;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_DVI_D:
    di_cta_vesa_display_device_interface_type = 5;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_DVI_I_ANALOG : di_cta_vesa_display_device_interface_type = 6 ;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_DVI_I_DIGITAL : di_cta_vesa_display_device_interface_type = 7 ;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_HDMI_A:
    di_cta_vesa_display_device_interface_type = 8;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_HDMI_B:
    di_cta_vesa_display_device_interface_type = 9;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_MDDI:
    di_cta_vesa_display_device_interface_type = 10;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_DISPLAYPORT : di_cta_vesa_display_device_interface_type = 11 ;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_IEEE_1394 : di_cta_vesa_display_device_interface_type = 12 ;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_M1_ANALOG : di_cta_vesa_display_device_interface_type = 13 ;
pub const di_cta_vesa_display_device_interface_type_DI_CTA_VESA_DISPLAY_DEVICE_INTERFACE_M1_DIGITAL : di_cta_vesa_display_device_interface_type = 14 ;
#[doc = " Interface types, defined in VESA DDDB section 2.3.1 and 2.3.2.\n\n Note, the enum values don't match the specification."]
pub type di_cta_vesa_display_device_interface_type = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_content_protection_DI_CTA_VESA_DISPLAY_DEVICE_CONTENT_PROTECTION_NONE : di_cta_vesa_display_device_content_protection = 0 ;
pub const di_cta_vesa_display_device_content_protection_DI_CTA_VESA_DISPLAY_DEVICE_CONTENT_PROTECTION_HDCP : di_cta_vesa_display_device_content_protection = 1 ;
pub const di_cta_vesa_display_device_content_protection_DI_CTA_VESA_DISPLAY_DEVICE_CONTENT_PROTECTION_DTCP : di_cta_vesa_display_device_content_protection = 2 ;
pub const di_cta_vesa_display_device_content_protection_DI_CTA_VESA_DISPLAY_DEVICE_CONTENT_PROTECTION_DPCP : di_cta_vesa_display_device_content_protection = 3 ;
pub type di_cta_vesa_display_device_content_protection = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_default_orientation_DI_CTA_VESA_DISPLAY_DEVICE_DEFAULT_ORIENTATION_LANDSCAPE : di_cta_vesa_display_device_default_orientation = 0 ;
pub const di_cta_vesa_display_device_default_orientation_DI_CTA_VESA_DISPLAY_DEVICE_DEFAULT_ORIENTATION_PORTAIT : di_cta_vesa_display_device_default_orientation = 1 ;
pub const di_cta_vesa_display_device_default_orientation_DI_CTA_VESA_DISPLAY_DEVICE_DEFAULT_ORIENTATION_UNFIXED : di_cta_vesa_display_device_default_orientation = 2 ;
pub const di_cta_vesa_display_device_default_orientation_DI_CTA_VESA_DISPLAY_DEVICE_DEFAULT_ORIENTATION_UNDEFINED : di_cta_vesa_display_device_default_orientation = 3 ;
pub type di_cta_vesa_display_device_default_orientation = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_rotation_cap_DI_CTA_VESA_DISPLAY_DEVICE_ROTATION_CAP_NONE:
    di_cta_vesa_display_device_rotation_cap = 0;
pub const di_cta_vesa_display_device_rotation_cap_DI_CTA_VESA_DISPLAY_DEVICE_ROTATION_CAP_90DEG_CLOCKWISE : di_cta_vesa_display_device_rotation_cap = 1 ;
pub const di_cta_vesa_display_device_rotation_cap_DI_CTA_VESA_DISPLAY_DEVICE_ROTATION_CAP_90DEG_COUNTERCLOCKWISE : di_cta_vesa_display_device_rotation_cap = 2 ;
pub const di_cta_vesa_display_device_rotation_cap_DI_CTA_VESA_DISPLAY_DEVICE_ROTATION_CAP_90DEG_EITHER : di_cta_vesa_display_device_rotation_cap = 3 ;
pub type di_cta_vesa_display_device_rotation_cap = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_zero_pixel_location_DI_CTA_VESA_DISPLAY_DEVICE_ZERO_PIXEL_UPPER_LEFT : di_cta_vesa_display_device_zero_pixel_location = 0 ;
pub const di_cta_vesa_display_device_zero_pixel_location_DI_CTA_VESA_DISPLAY_DEVICE_ZERO_PIXEL_UPPER_RIGHT : di_cta_vesa_display_device_zero_pixel_location = 1 ;
pub const di_cta_vesa_display_device_zero_pixel_location_DI_CTA_VESA_DISPLAY_DEVICE_ZERO_PIXEL_LOWER_LEFT : di_cta_vesa_display_device_zero_pixel_location = 2 ;
pub const di_cta_vesa_display_device_zero_pixel_location_DI_CTA_VESA_DISPLAY_DEVICE_ZERO_PIXEL_LOWER_RIGHT : di_cta_vesa_display_device_zero_pixel_location = 3 ;
pub type di_cta_vesa_display_device_zero_pixel_location = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_scan_direction_DI_CTA_VESA_DISPLAY_DEVICE_SCAN_DIRECTION_UNDEFINED : di_cta_vesa_display_device_scan_direction = 0 ;
pub const di_cta_vesa_display_device_scan_direction_DI_CTA_VESA_DISPLAY_DEVICE_SCAN_DIRECTION_FAST_LONG_SLOW_SHORT : di_cta_vesa_display_device_scan_direction = 1 ;
pub const di_cta_vesa_display_device_scan_direction_DI_CTA_VESA_DISPLAY_DEVICE_SCAN_DIRECTION_FAST_SHORT_SLOW_LONG : di_cta_vesa_display_device_scan_direction = 2 ;
pub type di_cta_vesa_display_device_scan_direction = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_UNDEFINED : di_cta_vesa_display_device_subpixel_layout = 0 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_RGB_VERT : di_cta_vesa_display_device_subpixel_layout = 1 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_RGB_HORIZ : di_cta_vesa_display_device_subpixel_layout = 2 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_EDID_CHROM_VERT : di_cta_vesa_display_device_subpixel_layout = 3 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_EDID_CHROM_HORIZ : di_cta_vesa_display_device_subpixel_layout = 4 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_QUAD_RGGB : di_cta_vesa_display_device_subpixel_layout = 5 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_QUAD_GBRG : di_cta_vesa_display_device_subpixel_layout = 6 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_DELTA_RGB : di_cta_vesa_display_device_subpixel_layout = 7 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_MOSAIC:
    di_cta_vesa_display_device_subpixel_layout = 8;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_QUAD_ANY : di_cta_vesa_display_device_subpixel_layout = 9 ;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_FIVE:
    di_cta_vesa_display_device_subpixel_layout = 10;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_SIX:
    di_cta_vesa_display_device_subpixel_layout = 11;
pub const di_cta_vesa_display_device_subpixel_layout_DI_CTA_VESA_DISPLAY_DEVICE_SUBPIXEL_CLAIRVOYANTE_PENTILE : di_cta_vesa_display_device_subpixel_layout = 12 ;
#[doc = " Subpixel layout, defined in VESA DDDB section 2.9.\n\n For layouts with more than 3 subpixels, the color coordinates of the\n additional subpixels are defined in the additional primary chromaticities."]
pub type di_cta_vesa_display_device_subpixel_layout = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_dithering_type_DI_CTA_VESA_DISPLAY_DEVICE_DITHERING_NONE:
    di_cta_vesa_display_device_dithering_type = 0;
pub const di_cta_vesa_display_device_dithering_type_DI_CTA_VESA_DISPLAY_DEVICE_DITHERING_SPACIAL:
    di_cta_vesa_display_device_dithering_type = 1;
pub const di_cta_vesa_display_device_dithering_type_DI_CTA_VESA_DISPLAY_DEVICE_DITHERING_TEMPORAL : di_cta_vesa_display_device_dithering_type = 2 ;
pub const di_cta_vesa_display_device_dithering_type_DI_CTA_VESA_DISPLAY_DEVICE_DITHERING_SPATIAL_AND_TEMPORAL : di_cta_vesa_display_device_dithering_type = 3 ;
pub type di_cta_vesa_display_device_dithering_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vesa_display_device_additional_primary_chromaticity {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_di_cta_vesa_display_device_additional_primary_chromaticity() {
    const UNINIT: ::std::mem::MaybeUninit<
        di_cta_vesa_display_device_additional_primary_chromaticity,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vesa_display_device_additional_primary_chromaticity>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_vesa_display_device_additional_primary_chromaticity)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vesa_display_device_additional_primary_chromaticity>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_vesa_display_device_additional_primary_chromaticity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_additional_primary_chromaticity),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_additional_primary_chromaticity),
            "::",
            stringify!(y)
        )
    );
}
pub const di_cta_vesa_display_device_frame_rate_conversion_DI_CTA_VESA_DISPLAY_DEVICE_FRAME_RATE_CONVERSION_NONE : di_cta_vesa_display_device_frame_rate_conversion = 0 ;
pub const di_cta_vesa_display_device_frame_rate_conversion_DI_CTA_VESA_DISPLAY_DEVICE_FRAME_RATE_CONVERSION_SINGLE_BUFFERING : di_cta_vesa_display_device_frame_rate_conversion = 1 ;
pub const di_cta_vesa_display_device_frame_rate_conversion_DI_CTA_VESA_DISPLAY_DEVICE_FRAME_RATE_CONVERSION_DOUBLE_BUFFERING : di_cta_vesa_display_device_frame_rate_conversion = 2 ;
pub const di_cta_vesa_display_device_frame_rate_conversion_DI_CTA_VESA_DISPLAY_DEVICE_FRAME_RATE_CONVERSION_ADVANCED : di_cta_vesa_display_device_frame_rate_conversion = 3 ;
pub type di_cta_vesa_display_device_frame_rate_conversion = ::std::os::raw::c_uint;
pub const di_cta_vesa_display_device_resp_time_transition_DI_CTA_VESA_DISPLAY_DEVICE_RESP_TIME_BLACK_TO_WHITE : di_cta_vesa_display_device_resp_time_transition = 0 ;
pub const di_cta_vesa_display_device_resp_time_transition_DI_CTA_VESA_DISPLAY_DEVICE_RESP_TIME_WHITE_TO_BLACK : di_cta_vesa_display_device_resp_time_transition = 1 ;
pub type di_cta_vesa_display_device_resp_time_transition = ::std::os::raw::c_uint;
#[doc = " VESA Display Device Data Block (DDDB), defined in VESA Display Device Data\n Block (DDDB) Standard version 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vesa_display_device_block {
    pub interface_type: di_cta_vesa_display_device_interface_type,
    pub num_channels: i32,
    pub interface_version: i32,
    pub interface_release: i32,
    pub content_protection: di_cta_vesa_display_device_content_protection,
    pub min_clock_freq_mhz: i32,
    pub max_clock_freq_mhz: i32,
    pub native_horiz_pixels: i32,
    pub native_vert_pixels: i32,
    pub aspect_ratio: f32,
    pub default_orientation: di_cta_vesa_display_device_default_orientation,
    pub rotation_cap: di_cta_vesa_display_device_rotation_cap,
    pub zero_pixel_location: di_cta_vesa_display_device_zero_pixel_location,
    pub scan_direction: di_cta_vesa_display_device_scan_direction,
    pub subpixel_layout: di_cta_vesa_display_device_subpixel_layout,
    pub horiz_pitch_mm: f32,
    pub vert_pitch_mm: f32,
    pub dithering_type: di_cta_vesa_display_device_dithering_type,
    pub direct_drive: bool,
    pub overdrive_not_recommended: bool,
    pub deinterlacing: bool,
    pub audio_support: bool,
    pub separate_audio_inputs: bool,
    pub audio_input_override: bool,
    pub audio_delay_provided: bool,
    pub audio_delay_ms: i32,
    pub frame_rate_conversion: di_cta_vesa_display_device_frame_rate_conversion,
    pub frame_rate_range_hz: i32,
    pub frame_rate_native_hz: i32,
    pub bit_depth_interface: i32,
    pub bit_depth_display: i32,
    pub additional_primary_chromaticities_len: usize,
    pub additional_primary_chromaticities:
        [di_cta_vesa_display_device_additional_primary_chromaticity; 3usize],
    pub resp_time_transition: di_cta_vesa_display_device_resp_time_transition,
    pub resp_time_ms: i32,
    pub overscan_horiz_pct: i32,
    pub overscan_vert_pct: i32,
}
#[test]
fn bindgen_test_layout_di_cta_vesa_display_device_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_vesa_display_device_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vesa_display_device_block>(),
        152usize,
        concat!("Size of: ", stringify!(di_cta_vesa_display_device_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vesa_display_device_block>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_vesa_display_device_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(interface_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(interface_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_release) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(interface_release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_protection) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(content_protection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_clock_freq_mhz) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(min_clock_freq_mhz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_clock_freq_mhz) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(max_clock_freq_mhz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_horiz_pixels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(native_horiz_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_vert_pixels) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(native_vert_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect_ratio) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_orientation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(default_orientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation_cap) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(rotation_cap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_pixel_location) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(zero_pixel_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scan_direction) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(scan_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subpixel_layout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(subpixel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horiz_pitch_mm) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(horiz_pitch_mm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vert_pitch_mm) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(vert_pitch_mm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dithering_type) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(dithering_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direct_drive) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(direct_drive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overdrive_not_recommended) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(overdrive_not_recommended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deinterlacing) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(deinterlacing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_support) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(audio_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).separate_audio_inputs) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(separate_audio_inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_input_override) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(audio_input_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_delay_provided) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(audio_delay_provided)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_delay_ms) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(audio_delay_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate_conversion) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(frame_rate_conversion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate_range_hz) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(frame_rate_range_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate_native_hz) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(frame_rate_native_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_interface) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(bit_depth_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_display) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(bit_depth_display)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).additional_primary_chromaticities_len) as usize
                - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(additional_primary_chromaticities_len)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).additional_primary_chromaticities) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(additional_primary_chromaticities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_time_transition) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(resp_time_transition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_time_ms) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(resp_time_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overscan_horiz_pct) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(overscan_horiz_pct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overscan_vert_pct) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_display_device_block),
            "::",
            stringify!(overscan_vert_pct)
        )
    );
}
extern "C" {
    #[doc = " Get the VESA Display Device Data Block (DDDB) from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_VESA_DISPLAY_DEVICE."]
    pub fn di_cta_data_block_get_vesa_display_device(
        block: *const di_cta_data_block,
    ) -> *const di_cta_vesa_display_device_block;
}
#[doc = " CTA colorimetry data block, defined in section 7.5.5."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_colorimetry_block {
    pub xvycc_601: bool,
    pub xvycc_709: bool,
    pub sycc_601: bool,
    pub opycc_601: bool,
    pub oprgb: bool,
    pub bt2020_cycc: bool,
    pub bt2020_ycc: bool,
    pub bt2020_rgb: bool,
    pub st2113_rgb: bool,
    pub ictcp: bool,
}
#[test]
fn bindgen_test_layout_di_cta_colorimetry_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_colorimetry_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_colorimetry_block>(),
        10usize,
        concat!("Size of: ", stringify!(di_cta_colorimetry_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_colorimetry_block>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_colorimetry_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xvycc_601) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(xvycc_601)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xvycc_709) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(xvycc_709)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sycc_601) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(sycc_601)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opycc_601) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(opycc_601)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oprgb) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(oprgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt2020_cycc) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(bt2020_cycc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt2020_ycc) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(bt2020_ycc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt2020_rgb) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(bt2020_rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st2113_rgb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(st2113_rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ictcp) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_colorimetry_block),
            "::",
            stringify!(ictcp)
        )
    );
}
extern "C" {
    #[doc = " Get the colorimetry data from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_COLORIMETRY."]
    pub fn di_cta_data_block_get_colorimetry(
        block: *const di_cta_data_block,
    ) -> *const di_cta_colorimetry_block;
}
#[doc = " Supported Electro-Optical Transfer Functions for a CTA HDR static metadata\n block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_static_metadata_eotfs {
    pub traditional_sdr: bool,
    pub traditional_hdr: bool,
    pub pq: bool,
    pub hlg: bool,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_static_metadata_eotfs() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_static_metadata_eotfs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_static_metadata_eotfs>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_hdr_static_metadata_eotfs))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_static_metadata_eotfs>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_static_metadata_eotfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traditional_sdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_eotfs),
            "::",
            stringify!(traditional_sdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traditional_hdr) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_eotfs),
            "::",
            stringify!(traditional_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pq) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_eotfs),
            "::",
            stringify!(pq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hlg) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_eotfs),
            "::",
            stringify!(hlg)
        )
    );
}
#[doc = " Supported static metadata descriptors for a CTA HDR static metadata block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_static_metadata_descriptors {
    pub type1: bool,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_static_metadata_descriptors() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_static_metadata_descriptors> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_static_metadata_descriptors>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_hdr_static_metadata_descriptors)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_static_metadata_descriptors>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_static_metadata_descriptors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_descriptors),
            "::",
            stringify!(type1)
        )
    );
}
#[doc = " CTA HDR static metadata block, defined in section 7.5.13."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_static_metadata_block {
    pub desired_content_max_luminance: f32,
    pub desired_content_max_frame_avg_luminance: f32,
    pub desired_content_min_luminance: f32,
    pub eotfs: *const di_cta_hdr_static_metadata_eotfs,
    pub descriptors: *const di_cta_hdr_static_metadata_descriptors,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_static_metadata_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_static_metadata_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_static_metadata_block>(),
        32usize,
        concat!("Size of: ", stringify!(di_cta_hdr_static_metadata_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_static_metadata_block>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_static_metadata_block)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_luminance) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(desired_content_max_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_frame_avg_luminance) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(desired_content_max_frame_avg_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_min_luminance) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(desired_content_min_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eotfs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(eotfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_static_metadata_block),
            "::",
            stringify!(descriptors)
        )
    );
}
extern "C" {
    #[doc = " Get the HDR static metadata from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_HDR_STATIC_METADATA."]
    pub fn di_cta_data_block_get_hdr_static_metadata(
        block: *const di_cta_data_block,
    ) -> *const di_cta_hdr_static_metadata_block;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_type1 {
    pub type_1_hdr_metadata_version: u8,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_type1() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_type1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_type1>(),
        1usize,
        concat!("Size of: ", stringify!(di_cta_hdr_dynamic_metadata_type1))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_type1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_type1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_1_hdr_metadata_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_type1),
            "::",
            stringify!(type_1_hdr_metadata_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_type2 {
    pub ts_103_433_spec_version: u8,
    pub ts_103_433_1_capable: bool,
    pub ts_103_433_2_capable: bool,
    pub ts_103_433_3_capable: bool,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_type2() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_type2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_type2>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_hdr_dynamic_metadata_type2))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_type2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_type2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_spec_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_type2),
            "::",
            stringify!(ts_103_433_spec_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_1_capable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_type2),
            "::",
            stringify!(ts_103_433_1_capable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_2_capable) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_type2),
            "::",
            stringify!(ts_103_433_2_capable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_103_433_3_capable) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_type2),
            "::",
            stringify!(ts_103_433_3_capable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_type3 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_type4 {
    pub type_4_hdr_metadata_version: u8,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_type4() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_type4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_type4>(),
        1usize,
        concat!("Size of: ", stringify!(di_cta_hdr_dynamic_metadata_type4))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_type4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_type4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_4_hdr_metadata_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_type4),
            "::",
            stringify!(type_4_hdr_metadata_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_type256 {
    pub graphics_overlay_flag_version: u8,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_type256() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_type256> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_type256>(),
        1usize,
        concat!("Size of: ", stringify!(di_cta_hdr_dynamic_metadata_type256))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_type256>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_type256)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).graphics_overlay_flag_version) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_type256),
            "::",
            stringify!(graphics_overlay_flag_version)
        )
    );
}
#[doc = " CTA HDR dynamic metadata block, defined in section 7.5.14."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr_dynamic_metadata_block {
    pub type1: *const di_cta_hdr_dynamic_metadata_type1,
    pub type2: *const di_cta_hdr_dynamic_metadata_type2,
    pub type3: *const di_cta_hdr_dynamic_metadata_type3,
    pub type4: *const di_cta_hdr_dynamic_metadata_type4,
    pub type256: *const di_cta_hdr_dynamic_metadata_type256,
}
#[test]
fn bindgen_test_layout_di_cta_hdr_dynamic_metadata_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr_dynamic_metadata_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr_dynamic_metadata_block>(),
        40usize,
        concat!("Size of: ", stringify!(di_cta_hdr_dynamic_metadata_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr_dynamic_metadata_block>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_hdr_dynamic_metadata_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type256) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr_dynamic_metadata_block),
            "::",
            stringify!(type256)
        )
    );
}
extern "C" {
    #[doc = " Get the HDR dynamic metadata from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_HDR_DYNAMIC_METADATA."]
    pub fn di_cta_data_block_get_hdr_dynamic_metadata(
        block: *const di_cta_data_block,
    ) -> *const di_cta_hdr_dynamic_metadata_block;
}
#[doc = " A Short Video Descriptor (SVD)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_svd {
    pub vic: u8,
    pub original_index: u8,
    pub native: bool,
}
#[test]
fn bindgen_test_layout_di_cta_svd() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_svd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_svd>(),
        3usize,
        concat!("Size of: ", stringify!(di_cta_svd))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_svd>(),
        1usize,
        concat!("Alignment of ", stringify!(di_cta_svd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svd),
            "::",
            stringify!(vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_index) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svd),
            "::",
            stringify!(original_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svd),
            "::",
            stringify!(native)
        )
    );
}
#[doc = " Video Data Block, defined in section 7.5.1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_video_block {
    pub svds: *const *const di_cta_svd,
}
#[test]
fn bindgen_test_layout_di_cta_video_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_video_block> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_video_block>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_video_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_video_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_video_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_block),
            "::",
            stringify!(svds)
        )
    );
}
extern "C" {
    #[doc = " Get the video from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_VIDEO."]
    pub fn di_cta_data_block_get_video(
        block: *const di_cta_data_block,
    ) -> *const di_cta_video_block;
}
#[doc = " Video Data Block, defined in section 7.5.1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_ycbcr420_video_block {
    pub svds: *const *const di_cta_svd,
}
#[test]
fn bindgen_test_layout_di_cta_ycbcr420_video_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_ycbcr420_video_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_ycbcr420_video_block>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_ycbcr420_video_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_ycbcr420_video_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_ycbcr420_video_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_ycbcr420_video_block),
            "::",
            stringify!(svds)
        )
    );
}
extern "C" {
    #[doc = " Get the YCbCr video from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_YCBCR420."]
    pub fn di_cta_data_block_get_ycbcr420_video(
        block: *const di_cta_data_block,
    ) -> *const di_cta_ycbcr420_video_block;
}
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_WHITE : di_cta_vesa_transfer_characteristics_usage = 0 ;
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_RED : di_cta_vesa_transfer_characteristics_usage = 1 ;
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_GREEN : di_cta_vesa_transfer_characteristics_usage = 2 ;
pub const di_cta_vesa_transfer_characteristics_usage_DI_CTA_VESA_TRANSFER_CHARACTERISTIC_USAGE_BLUE : di_cta_vesa_transfer_characteristics_usage = 3 ;
pub type di_cta_vesa_transfer_characteristics_usage = ::std::os::raw::c_uint;
#[doc = " VESA Display Transfer Characteristic Data Block, defined in VESA Display\n Transfer Characteristics Data Block Standard Version 1.0\n\n Contains 8, 16 or 32 evenly distributed points on the input axis describing\n the normalized relative luminance at that input. The first value includes the\n relative black level luminance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vesa_transfer_characteristics_block {
    pub usage: di_cta_vesa_transfer_characteristics_usage,
    pub points_len: u8,
    pub points: [f32; 32usize],
}
#[test]
fn bindgen_test_layout_di_cta_vesa_transfer_characteristics_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_vesa_transfer_characteristics_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vesa_transfer_characteristics_block>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(di_cta_vesa_transfer_characteristics_block)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vesa_transfer_characteristics_block>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_vesa_transfer_characteristics_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_transfer_characteristics_block),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_transfer_characteristics_block),
            "::",
            stringify!(points_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vesa_transfer_characteristics_block),
            "::",
            stringify!(points)
        )
    );
}
extern "C" {
    #[doc = " Get the Display Transfer Characteristic from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_VESA_DISPLAY_TRANSFER_CHARACTERISTIC.\n\n Upstream is not aware of any EDID blob containing a Display Transfer\n Characteristic data block.\n If such a blob is found, please share it with upstream!"]
    pub fn di_cta_data_block_get_vesa_transfer_characteristics(
        block: *const di_cta_data_block,
    ) -> *const di_cta_vesa_transfer_characteristics_block;
}
#[doc = " CTA YCbCr 4:2:0 Capability Map block, defined in section 7.5.11."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_ycbcr420_cap_map_block {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns true if the SVD in regular Video Data Blocks at index `svd_index`\n supports YCbCr 4:2:0 subsampling."]
    pub fn di_cta_ycbcr420_cap_map_supported(
        cap_map: *const di_cta_ycbcr420_cap_map_block,
        svd_index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the YCbCr 4:2:0 Capability Map from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_YCBCR420_CAP_MAP."]
    pub fn di_cta_data_block_get_ycbcr420_cap_map(
        block: *const di_cta_data_block,
    ) -> *const di_cta_ycbcr420_cap_map_block;
}
pub const di_cta_hdmi_audio_3d_channels_DI_CTA_HDMI_AUDIO_3D_CHANNELS_UNKNOWN:
    di_cta_hdmi_audio_3d_channels = 0;
pub const di_cta_hdmi_audio_3d_channels_DI_CTA_HDMI_AUDIO_3D_CHANNELS_10_2:
    di_cta_hdmi_audio_3d_channels = 1;
pub const di_cta_hdmi_audio_3d_channels_DI_CTA_HDMI_AUDIO_3D_CHANNELS_22_2:
    di_cta_hdmi_audio_3d_channels = 2;
pub const di_cta_hdmi_audio_3d_channels_DI_CTA_HDMI_AUDIO_3D_CHANNELS_30_2:
    di_cta_hdmi_audio_3d_channels = 3;
pub type di_cta_hdmi_audio_3d_channels = ::std::os::raw::c_uint;
#[doc = " HDMI 3D Audio"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdmi_audio_3d {
    pub sads: *const *const di_cta_sad,
    pub channels: di_cta_hdmi_audio_3d_channels,
    pub speakers: di_cta_speaker_allocation,
}
#[test]
fn bindgen_test_layout_di_cta_hdmi_audio_3d() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdmi_audio_3d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdmi_audio_3d>(),
        32usize,
        concat!("Size of: ", stringify!(di_cta_hdmi_audio_3d))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdmi_audio_3d>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_hdmi_audio_3d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sads) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_audio_3d),
            "::",
            stringify!(sads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_audio_3d),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_audio_3d),
            "::",
            stringify!(speakers)
        )
    );
}
#[doc = " HDMI Multi-Stream Audio"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdmi_audio_multi_stream {
    pub max_streams: ::std::os::raw::c_int,
    pub supports_non_mixed: bool,
}
#[test]
fn bindgen_test_layout_di_cta_hdmi_audio_multi_stream() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdmi_audio_multi_stream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdmi_audio_multi_stream>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_hdmi_audio_multi_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdmi_audio_multi_stream>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_hdmi_audio_multi_stream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_streams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_audio_multi_stream),
            "::",
            stringify!(max_streams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_non_mixed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_audio_multi_stream),
            "::",
            stringify!(supports_non_mixed)
        )
    );
}
#[doc = " HDMI Audio"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdmi_audio_block {
    pub multi_stream: *const di_cta_hdmi_audio_multi_stream,
    pub audio_3d: *const di_cta_hdmi_audio_3d,
}
#[test]
fn bindgen_test_layout_di_cta_hdmi_audio_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdmi_audio_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdmi_audio_block>(),
        16usize,
        concat!("Size of: ", stringify!(di_cta_hdmi_audio_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdmi_audio_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_hdmi_audio_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multi_stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_audio_block),
            "::",
            stringify!(multi_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_3d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_audio_block),
            "::",
            stringify!(audio_3d)
        )
    );
}
extern "C" {
    #[doc = " Get the HDMI Audio information from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_HDMI_AUDIO."]
    pub fn di_cta_data_block_get_hdmi_audio(
        block: *const di_cta_data_block,
    ) -> *const di_cta_hdmi_audio_block;
}
#[doc = " HDR10+ Vendor-Specific Video Data Block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdr10plus_block {
    pub version: ::std::os::raw::c_int,
    pub peak_lum: ::std::os::raw::c_int,
    pub ff_peak_lum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_di_cta_hdr10plus_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdr10plus_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdr10plus_block>(),
        12usize,
        concat!("Size of: ", stringify!(di_cta_hdr10plus_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdr10plus_block>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_hdr10plus_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr10plus_block),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peak_lum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr10plus_block),
            "::",
            stringify!(peak_lum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ff_peak_lum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdr10plus_block),
            "::",
            stringify!(ff_peak_lum)
        )
    );
}
extern "C" {
    #[doc = " Get the HDR10+ information from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_HDR10PLUS."]
    pub fn di_cta_data_block_get_hdr10plus(
        block: *const di_cta_data_block,
    ) -> *const di_cta_hdr10plus_block;
}
pub const di_cta_dolby_video_colorimetry_DI_CTA_DOLBY_VIDEO_COLORIMETRY_BT_709:
    di_cta_dolby_video_colorimetry = 0;
pub const di_cta_dolby_video_colorimetry_DI_CTA_DOLBY_VIDEO_COLORIMETRY_P3_D65:
    di_cta_dolby_video_colorimetry = 1;
#[doc = " Dolby Video Colorimetry"]
pub type di_cta_dolby_video_colorimetry = ::std::os::raw::c_uint;
pub const di_cta_dolby_video_yuv444_DI_CTA_DOLBY_VIDEO_YUV444_NONE: di_cta_dolby_video_yuv444 = 0;
pub const di_cta_dolby_video_yuv444_DI_CTA_DOLBY_VIDEO_YUV444_10_BITS: di_cta_dolby_video_yuv444 =
    1;
pub const di_cta_dolby_video_yuv444_DI_CTA_DOLBY_VIDEO_YUV444_12_BITS: di_cta_dolby_video_yuv444 =
    2;
#[doc = " Dolby Video YUV 4:4:4 support"]
pub type di_cta_dolby_video_yuv444 = ::std::os::raw::c_uint;
#[doc = " Dolby Video Version 0 Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_dolby_video_block_v0 {
    pub yuv422_12bit: bool,
    pub global_dimming: bool,
    pub supports_2160p60: bool,
    pub dynamic_metadata_version_major: ::std::os::raw::c_int,
    pub dynamic_metadata_version_minor: ::std::os::raw::c_int,
    pub target_pq_12b_level_min: ::std::os::raw::c_int,
    pub target_pq_12b_level_max: ::std::os::raw::c_int,
    pub red_x: f64,
    pub red_y: f64,
    pub green_x: f64,
    pub green_y: f64,
    pub blue_x: f64,
    pub blue_y: f64,
    pub white_x: f64,
    pub white_y: f64,
}
#[test]
fn bindgen_test_layout_di_cta_dolby_video_block_v0() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_dolby_video_block_v0> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_dolby_video_block_v0>(),
        88usize,
        concat!("Size of: ", stringify!(di_cta_dolby_video_block_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_dolby_video_block_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_dolby_video_block_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv422_12bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(yuv422_12bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_dimming) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(global_dimming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_2160p60) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(supports_2160p60)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_metadata_version_major) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(dynamic_metadata_version_major)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_metadata_version_minor) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(dynamic_metadata_version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_pq_12b_level_min) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(target_pq_12b_level_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_pq_12b_level_max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(target_pq_12b_level_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(red_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(red_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_x) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(green_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(green_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_x) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(blue_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(blue_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_x) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(white_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_y) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v0),
            "::",
            stringify!(white_y)
        )
    );
}
#[doc = " Dolby Video Version 1 Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_dolby_video_block_v1 {
    pub yuv422_12bit: bool,
    pub global_dimming: bool,
    pub supports_2160p60: bool,
    pub dynamic_metadata_version: ::std::os::raw::c_int,
    pub colorimetry: di_cta_dolby_video_colorimetry,
    pub target_luminance_min: f64,
    pub target_luminance_max: f64,
    pub mode_low_latency: bool,
    pub unique_primaries: bool,
    pub red_x: f64,
    pub red_y: f64,
    pub green_x: f64,
    pub green_y: f64,
    pub blue_x: f64,
    pub blue_y: f64,
}
#[test]
fn bindgen_test_layout_di_cta_dolby_video_block_v1() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_dolby_video_block_v1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_dolby_video_block_v1>(),
        88usize,
        concat!("Size of: ", stringify!(di_cta_dolby_video_block_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_dolby_video_block_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_dolby_video_block_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv422_12bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(yuv422_12bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_dimming) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(global_dimming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_2160p60) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(supports_2160p60)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_metadata_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(dynamic_metadata_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(colorimetry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_luminance_min) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(target_luminance_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_luminance_max) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(target_luminance_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_low_latency) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(mode_low_latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unique_primaries) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(unique_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_x) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(red_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(red_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_x) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(green_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(green_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_x) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(blue_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_y) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v1),
            "::",
            stringify!(blue_y)
        )
    );
}
#[doc = " Dolby Video Version 2 Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_dolby_video_block_v2 {
    pub yuv422_12bit: bool,
    pub global_dimming: bool,
    pub dynamic_metadata_version: ::std::os::raw::c_int,
    pub backlight_control: bool,
    pub backlight_luminance_min: f64,
    pub mode_standard: bool,
    pub mode_low_latency_hdmi: bool,
    pub yuv444: di_cta_dolby_video_yuv444,
    pub target_pq_12b_level_min: ::std::os::raw::c_int,
    pub target_pq_12b_level_max: ::std::os::raw::c_int,
    pub red_x: f64,
    pub red_y: f64,
    pub green_x: f64,
    pub green_y: f64,
    pub blue_x: f64,
    pub blue_y: f64,
}
#[test]
fn bindgen_test_layout_di_cta_dolby_video_block_v2() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_dolby_video_block_v2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_dolby_video_block_v2>(),
        88usize,
        concat!("Size of: ", stringify!(di_cta_dolby_video_block_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_dolby_video_block_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_dolby_video_block_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv422_12bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(yuv422_12bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_dimming) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(global_dimming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_metadata_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(dynamic_metadata_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backlight_control) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(backlight_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backlight_luminance_min) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(backlight_luminance_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_standard) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(mode_standard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_low_latency_hdmi) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(mode_low_latency_hdmi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv444) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(yuv444)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_pq_12b_level_min) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(target_pq_12b_level_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_pq_12b_level_max) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(target_pq_12b_level_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_x) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(red_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(red_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_x) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(green_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(green_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_x) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(blue_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_y) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block_v2),
            "::",
            stringify!(blue_y)
        )
    );
}
pub const di_cta_dolby_video_version_DI_CTA_DOLBY_VIDEO_VERSION0: di_cta_dolby_video_version = 0;
pub const di_cta_dolby_video_version_DI_CTA_DOLBY_VIDEO_VERSION1: di_cta_dolby_video_version = 1;
pub const di_cta_dolby_video_version_DI_CTA_DOLBY_VIDEO_VERSION2: di_cta_dolby_video_version = 2;
#[doc = " Dolby Video Data Block version"]
pub type di_cta_dolby_video_version = ::std::os::raw::c_uint;
#[doc = " Dolby Video Data Block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_dolby_video_block {
    pub version: di_cta_dolby_video_version,
    pub v0: *const di_cta_dolby_video_block_v0,
    pub v1: *const di_cta_dolby_video_block_v1,
    pub v2: *const di_cta_dolby_video_block_v2,
}
#[test]
fn bindgen_test_layout_di_cta_dolby_video_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_dolby_video_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_dolby_video_block>(),
        32usize,
        concat!("Size of: ", stringify!(di_cta_dolby_video_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_dolby_video_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_dolby_video_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block),
            "::",
            stringify!(v0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_dolby_video_block),
            "::",
            stringify!(v2)
        )
    );
}
extern "C" {
    #[doc = " Get the Dolby Vision information from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_DOLBY_VIDEO."]
    pub fn di_cta_data_block_get_dolby_video(
        block: *const di_cta_data_block,
    ) -> *const di_cta_dolby_video_block;
}
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_AUXILIARY_VIDEO_INFORMATION:
    di_cta_infoframe_type = 0;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_SOURCE_PRODUCT_DESCRIPTION:
    di_cta_infoframe_type = 1;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_AUDIO: di_cta_infoframe_type = 2;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_MPEG_SOURCE: di_cta_infoframe_type = 3;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_NTSC_VBI: di_cta_infoframe_type = 4;
pub const di_cta_infoframe_type_DI_CTA_INFOFRAME_TYPE_DYNAMIC_RANGE_AND_MASTERING:
    di_cta_infoframe_type = 5;
#[doc = " InfoFrame types, defined in table 7.\n\n Note, the enum values don't match the specification."]
pub type di_cta_infoframe_type = ::std::os::raw::c_uint;
#[doc = " CTA InfoFrame descriptor, defined in section 7.5.9."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_infoframe_descriptor {
    pub type_: di_cta_infoframe_type,
}
#[test]
fn bindgen_test_layout_di_cta_infoframe_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_infoframe_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_infoframe_descriptor>(),
        4usize,
        concat!("Size of: ", stringify!(di_cta_infoframe_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_infoframe_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_infoframe_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_infoframe_descriptor),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " CTA InfoFrame processing, defined in section 7.5.9."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_infoframe_block {
    pub num_simultaneous_vsifs: ::std::os::raw::c_int,
    pub infoframes: *const *const di_cta_infoframe_descriptor,
}
#[test]
fn bindgen_test_layout_di_cta_infoframe_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_infoframe_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_infoframe_block>(),
        16usize,
        concat!("Size of: ", stringify!(di_cta_infoframe_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_infoframe_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_infoframe_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_simultaneous_vsifs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_infoframe_block),
            "::",
            stringify!(num_simultaneous_vsifs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infoframes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_infoframe_block),
            "::",
            stringify!(infoframes)
        )
    );
}
extern "C" {
    #[doc = " Get the InfoFrame information from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_INFOFRAME."]
    pub fn di_cta_data_block_get_infoframe(
        block: *const di_cta_data_block,
    ) -> *const di_cta_infoframe_block;
}
#[doc = " Room Configuration Data Block, defined in section 7.5.15."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_room_configuration_block {
    pub speakers: di_cta_speaker_allocation,
    pub speaker_count: ::std::os::raw::c_int,
    pub has_speaker_location_descriptors: bool,
    pub max_x: ::std::os::raw::c_int,
    pub max_y: ::std::os::raw::c_int,
    pub max_z: ::std::os::raw::c_int,
    pub display_x: f64,
    pub display_y: f64,
    pub display_z: f64,
}
#[test]
fn bindgen_test_layout_di_cta_room_configuration_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_room_configuration_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_room_configuration_block>(),
        64usize,
        concat!("Size of: ", stringify!(di_cta_room_configuration_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_room_configuration_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_room_configuration_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speaker_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(speaker_count)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).has_speaker_location_descriptors) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(has_speaker_location_descriptors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(max_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(max_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_z) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(max_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_x) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(display_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(display_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_z) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_room_configuration_block),
            "::",
            stringify!(display_z)
        )
    );
}
extern "C" {
    #[doc = " Get the Room Configuration from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_ROOM_CONFIG."]
    pub fn di_cta_data_block_get_room_configuration(
        block: *const di_cta_data_block,
    ) -> *const di_cta_room_configuration_block;
}
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_FL: di_cta_speaker_placement = 0;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_FR: di_cta_speaker_placement = 1;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_FC: di_cta_speaker_placement = 2;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_LFE1: di_cta_speaker_placement = 3;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_BL: di_cta_speaker_placement = 4;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_BR: di_cta_speaker_placement = 5;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_FLC: di_cta_speaker_placement = 6;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_FRC: di_cta_speaker_placement = 7;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_BC: di_cta_speaker_placement = 8;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_LFE2: di_cta_speaker_placement = 9;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_SIL: di_cta_speaker_placement = 10;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_SIR: di_cta_speaker_placement = 11;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPFL: di_cta_speaker_placement = 12;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPFR: di_cta_speaker_placement = 13;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPFC: di_cta_speaker_placement = 14;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPC: di_cta_speaker_placement = 15;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPBL: di_cta_speaker_placement = 16;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPBR: di_cta_speaker_placement = 17;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPSIL: di_cta_speaker_placement = 18;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPSIR: di_cta_speaker_placement = 19;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_TPBC: di_cta_speaker_placement = 20;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_BTFC: di_cta_speaker_placement = 21;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_BTFL: di_cta_speaker_placement = 22;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_BRFR: di_cta_speaker_placement = 23;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_FLW: di_cta_speaker_placement = 24;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_FRW: di_cta_speaker_placement = 25;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_LS: di_cta_speaker_placement = 26;
pub const di_cta_speaker_placement_DI_CTA_SPEAKER_PLACEMENT_RS: di_cta_speaker_placement = 27;
pub type di_cta_speaker_placement = ::std::os::raw::c_uint;
#[doc = " Speaker Location Descriptor, defined in section 7.5.16."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_speaker_location_descriptor {
    pub channel_index: ::std::os::raw::c_int,
    pub is_active: bool,
    pub has_coords: bool,
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub speaker_id: di_cta_speaker_placement,
}
#[test]
fn bindgen_test_layout_di_cta_speaker_location_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_speaker_location_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_speaker_location_descriptor>(),
        40usize,
        concat!("Size of: ", stringify!(di_cta_speaker_location_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_speaker_location_descriptor>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(di_cta_speaker_location_descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_descriptor),
            "::",
            stringify!(channel_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_active) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_descriptor),
            "::",
            stringify!(is_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_coords) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_descriptor),
            "::",
            stringify!(has_coords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_descriptor),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_descriptor),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_descriptor),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speaker_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_descriptor),
            "::",
            stringify!(speaker_id)
        )
    );
}
#[doc = " Speaker Location Data Block, defined in section 7.5.16."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_speaker_location_block {
    pub locations: *const *const di_cta_speaker_location_descriptor,
}
#[test]
fn bindgen_test_layout_di_cta_speaker_location_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_speaker_location_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_speaker_location_block>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_speaker_location_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_speaker_location_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_speaker_location_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_speaker_location_block),
            "::",
            stringify!(locations)
        )
    );
}
extern "C" {
    #[doc = " Get the Speaker Locations from a CTA data block.\n\n Returns NULL if the data block tag is not DI_CTA_DATA_BLOCK_SPEAKER_LOCATION."]
    pub fn di_cta_data_block_get_speaker_locations(
        block: *const di_cta_data_block,
    ) -> *const di_cta_speaker_location_block;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_displayid_type_i_ii_vii_timing {
    _unused: [u8; 0],
}
#[doc = " Type VII Video Timing Data Block, defined in section 7.5.17.1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_type_vii_timing_block {
    pub timing: *const di_displayid_type_i_ii_vii_timing,
}
#[test]
fn bindgen_test_layout_di_cta_type_vii_timing_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_type_vii_timing_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_type_vii_timing_block>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_type_vii_timing_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_type_vii_timing_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_type_vii_timing_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_type_vii_timing_block),
            "::",
            stringify!(timing)
        )
    );
}
extern "C" {
    #[doc = " Get the DisplayID Type VII Video Timing from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_DISPLAYID_VIDEO_TIMING_VII."]
    pub fn di_cta_data_block_get_did_type_vii_timing(
        block: *const di_cta_data_block,
    ) -> *const di_cta_type_vii_timing_block;
}
#[doc = " HDMI vendor-specific data block.\n\n This block is defined in HDMI 1.4b section 8.3.2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vendor_hdmi_block {
    pub source_phys_addr: u16,
    pub supports_ai: bool,
    pub supports_dc_48bit: bool,
    pub supports_dc_36bit: bool,
    pub supports_dc_30bit: bool,
    pub supports_dc_y444: bool,
    pub supports_dvi_dual: bool,
    pub max_tmds_clock: ::std::os::raw::c_int,
    pub supports_content_graphics: bool,
    pub supports_content_photo: bool,
    pub supports_content_cinema: bool,
    pub supports_content_game: bool,
    #[doc = " If !has_latency and !has_interlaced_latency, we have no latency\n information at all.\n\n If only has_latency, video/audio latency fields are valid and\n should be used for both progressive and interlaced video/audio\n formats.\n\n If both are valid, it means that video_latency and audio_latency\n should be used for progressive video/audio formats, and their\n interlaced counterpart for interlaced formats."]
    pub has_latency: bool,
    pub has_interlaced_latency: bool,
    pub supports_progressive_video: bool,
    pub supports_progressive_audio: bool,
    pub supports_interlaced_video: bool,
    pub supports_interlaced_audio: bool,
    pub progressive_video_latency: ::std::os::raw::c_int,
    pub progressive_audio_latency: ::std::os::raw::c_int,
    pub interlaced_video_latency: ::std::os::raw::c_int,
    pub interlaced_audio_latency: ::std::os::raw::c_int,
    pub vics_len: usize,
    pub vics: *const u8,
}
#[test]
fn bindgen_test_layout_di_cta_vendor_hdmi_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_vendor_hdmi_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vendor_hdmi_block>(),
        56usize,
        concat!("Size of: ", stringify!(di_cta_vendor_hdmi_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vendor_hdmi_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_vendor_hdmi_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_phys_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(source_phys_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_ai) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_ai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dc_48bit) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_dc_48bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dc_36bit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_dc_36bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dc_30bit) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_dc_30bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dc_y444) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_dc_y444)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dvi_dual) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_dvi_dual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_tmds_clock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(max_tmds_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_content_graphics) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_content_graphics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_content_photo) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_content_photo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_content_cinema) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_content_cinema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_content_game) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_content_game)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_latency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(has_latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_interlaced_latency) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(has_interlaced_latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_progressive_video) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_progressive_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_progressive_audio) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_progressive_audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_interlaced_video) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_interlaced_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_interlaced_audio) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(supports_interlaced_audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progressive_video_latency) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(progressive_video_latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progressive_audio_latency) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(progressive_audio_latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced_video_latency) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(interlaced_video_latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced_audio_latency) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(interlaced_audio_latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vics_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(vics_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vics) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_block),
            "::",
            stringify!(vics)
        )
    );
}
extern "C" {
    #[doc = " Get the vendor-specific HDMI information from a CTA data block.\n\n Note, the HDMI and HDMI Forum vendor-specific data blocks are different.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_VENDOR_HDMI."]
    pub fn di_cta_data_block_get_vendor_hdmi(
        block: *const di_cta_data_block,
    ) -> *const di_cta_vendor_hdmi_block;
}
pub const di_cta_hdmi_frl_DI_CTA_HDMI_FRL_UNSUPPORTED: di_cta_hdmi_frl = 0;
pub const di_cta_hdmi_frl_DI_CTA_HDMI_FRL_3GBPS_3LANES: di_cta_hdmi_frl = 1;
pub const di_cta_hdmi_frl_DI_CTA_HDMI_FRL_6GBPS_3LANES: di_cta_hdmi_frl = 2;
pub const di_cta_hdmi_frl_DI_CTA_HDMI_FRL_6GBPS_4LANES: di_cta_hdmi_frl = 3;
pub const di_cta_hdmi_frl_DI_CTA_HDMI_FRL_8GBPS_4LANES: di_cta_hdmi_frl = 4;
pub const di_cta_hdmi_frl_DI_CTA_HDMI_FRL_10GBPS_4LANES: di_cta_hdmi_frl = 5;
pub const di_cta_hdmi_frl_DI_CTA_HDMI_FRL_12GBPS_4LANES: di_cta_hdmi_frl = 6;
#[doc = " Fixed Rate Link (FRL) support."]
pub type di_cta_hdmi_frl = ::std::os::raw::c_uint;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_UNSUPPORTED:
    di_cta_hdmi_dsc_max_slices = 0;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_1_340MHZ:
    di_cta_hdmi_dsc_max_slices = 1;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_2_340MHZ:
    di_cta_hdmi_dsc_max_slices = 2;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_4_340MHZ:
    di_cta_hdmi_dsc_max_slices = 3;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_8_340MHZ:
    di_cta_hdmi_dsc_max_slices = 4;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_8_400MHZ:
    di_cta_hdmi_dsc_max_slices = 5;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_12_400MHZ:
    di_cta_hdmi_dsc_max_slices = 6;
pub const di_cta_hdmi_dsc_max_slices_DI_CTA_HDMI_DSC_MAX_SLICES_16_400MHZ:
    di_cta_hdmi_dsc_max_slices = 7;
pub type di_cta_hdmi_dsc_max_slices = ::std::os::raw::c_uint;
#[doc = " Display Stream Compression (DSC) support."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdmi_dsc {
    pub supports_10bpc: bool,
    pub supports_12bpc: bool,
    pub supports_all_bpc: bool,
    pub supports_native_420: bool,
    pub max_slices: di_cta_hdmi_dsc_max_slices,
    pub max_frl_rate: di_cta_hdmi_frl,
    pub max_total_chunk_bytes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_di_cta_hdmi_dsc() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdmi_dsc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdmi_dsc>(),
        16usize,
        concat!("Size of: ", stringify!(di_cta_hdmi_dsc))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdmi_dsc>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_hdmi_dsc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_10bpc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_dsc),
            "::",
            stringify!(supports_10bpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_12bpc) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_dsc),
            "::",
            stringify!(supports_12bpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_all_bpc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_dsc),
            "::",
            stringify!(supports_all_bpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_native_420) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_dsc),
            "::",
            stringify!(supports_native_420)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_slices) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_dsc),
            "::",
            stringify!(max_slices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_frl_rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_dsc),
            "::",
            stringify!(max_frl_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_total_chunk_bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_dsc),
            "::",
            stringify!(max_total_chunk_bytes)
        )
    );
}
#[doc = " HDMI Sink Capability Data Structure (SCDS).\n\n This data is exposed via HDMI Forum Vendor-Specific Data Block (HF-VSDB) or\n the HDMI Forum Sink Capability Data Block (HF-SCDB)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdmi_scds {
    pub version: ::std::os::raw::c_int,
    pub max_tmds_char_rate_mhz: ::std::os::raw::c_int,
    pub supports_3d_osd_disparity: bool,
    pub supports_3d_dual_view: bool,
    pub supports_3d_independent_view: bool,
    pub supports_lte_340mcsc_scramble: bool,
    pub supports_ccbpci: bool,
    pub supports_cable_status: bool,
    pub supports_scdc_read_request: bool,
    pub supports_scdc: bool,
    pub supports_dc_30bit_420: bool,
    pub supports_dc_36bit_420: bool,
    pub supports_dc_48bit_420: bool,
    pub supports_uhd_vic: bool,
    pub max_frl_rate: di_cta_hdmi_frl,
    pub supports_fapa_start_location: bool,
    pub supports_allm: bool,
    pub supports_fva: bool,
    pub supports_neg_mvrr: bool,
    pub supports_cinema_vrr: bool,
    pub m_delta: bool,
    pub supports_qms: bool,
    pub supports_fapa_end_extended: bool,
    pub vrr_min_hz: ::std::os::raw::c_int,
    pub vrr_max_hz: ::std::os::raw::c_int,
    pub qms_tfr_min: bool,
    pub qms_tfr_max: bool,
    pub dsc: *const di_cta_hdmi_dsc,
}
#[test]
fn bindgen_test_layout_di_cta_hdmi_scds() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdmi_scds> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdmi_scds>(),
        56usize,
        concat!("Size of: ", stringify!(di_cta_hdmi_scds))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdmi_scds>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_hdmi_scds))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_tmds_char_rate_mhz) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(max_tmds_char_rate_mhz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_3d_osd_disparity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_3d_osd_disparity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_3d_dual_view) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_3d_dual_view)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_3d_independent_view) as usize - ptr as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_3d_independent_view)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_lte_340mcsc_scramble) as usize - ptr as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_lte_340mcsc_scramble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_ccbpci) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_ccbpci)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_cable_status) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_cable_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_scdc_read_request) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_scdc_read_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_scdc) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_scdc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dc_30bit_420) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_dc_30bit_420)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dc_36bit_420) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_dc_36bit_420)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dc_48bit_420) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_dc_48bit_420)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_uhd_vic) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_uhd_vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_frl_rate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(max_frl_rate)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).supports_fapa_start_location) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_fapa_start_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_allm) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_allm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_fva) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_fva)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_neg_mvrr) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_neg_mvrr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_cinema_vrr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_cinema_vrr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_delta) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(m_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_qms) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_qms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_fapa_end_extended) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(supports_fapa_end_extended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vrr_min_hz) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(vrr_min_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vrr_max_hz) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(vrr_max_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qms_tfr_min) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(qms_tfr_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qms_tfr_max) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(qms_tfr_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_scds),
            "::",
            stringify!(dsc)
        )
    );
}
#[doc = " HDMI Forum vendor-specific data block (HF-VSDB).\n\n This block is defined in HDMI 2.1 section 10.3.2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_vendor_hdmi_forum_block {
    pub scds: di_cta_hdmi_scds,
}
#[test]
fn bindgen_test_layout_di_cta_vendor_hdmi_forum_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_vendor_hdmi_forum_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_vendor_hdmi_forum_block>(),
        56usize,
        concat!("Size of: ", stringify!(di_cta_vendor_hdmi_forum_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_vendor_hdmi_forum_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_vendor_hdmi_forum_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_vendor_hdmi_forum_block),
            "::",
            stringify!(scds)
        )
    );
}
extern "C" {
    #[doc = " Get the vendor-specific HDMI Forum information from a CTA data block.\n\n Note, the HDMI and HDMI Forum vendor-specific data blocks are different.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_VENDOR_HDMI_FORUM."]
    pub fn di_cta_data_block_get_vendor_hdmi_forum(
        block: *const di_cta_data_block,
    ) -> *const di_cta_vendor_hdmi_forum_block;
}
#[doc = " HDMI Forum Sink Capability Data Block (HF-SCDB).\n\n This block is defined in HDMI 2.1a"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_hdmi_forum_sink_cap {
    pub scds: di_cta_hdmi_scds,
}
#[test]
fn bindgen_test_layout_di_cta_hdmi_forum_sink_cap() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_hdmi_forum_sink_cap> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_hdmi_forum_sink_cap>(),
        56usize,
        concat!("Size of: ", stringify!(di_cta_hdmi_forum_sink_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_hdmi_forum_sink_cap>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_hdmi_forum_sink_cap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_hdmi_forum_sink_cap),
            "::",
            stringify!(scds)
        )
    );
}
extern "C" {
    #[doc = " Get the HDMI Forum Sink Capability (HF-SCDB) from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_HDMI_SINK_CAP."]
    pub fn di_cta_data_block_get_hdmi_sink_cap(
        block: *const di_cta_data_block,
    ) -> *const di_cta_hdmi_forum_sink_cap;
}
pub const di_cta_svr_type_DI_CTA_SVR_TYPE_VIC: di_cta_svr_type = 0;
pub const di_cta_svr_type_DI_CTA_SVR_TYPE_DTD_INDEX: di_cta_svr_type = 1;
pub const di_cta_svr_type_DI_CTA_SVR_TYPE_T7T10VTDB: di_cta_svr_type = 2;
pub const di_cta_svr_type_DI_CTA_SVR_TYPE_FIRST_T8VTDB: di_cta_svr_type = 3;
pub type di_cta_svr_type = ::std::os::raw::c_uint;
#[doc = " Short Video Reference, defined in section 7.5.12."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_svr {
    pub type_: di_cta_svr_type,
    pub vic: u8,
    pub dtd_index: u8,
    pub t7_t10_vtdb_index: u8,
}
#[test]
fn bindgen_test_layout_di_cta_svr() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_svr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_svr>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_svr))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_svr>(),
        4usize,
        concat!("Alignment of ", stringify!(di_cta_svr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vic) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svr),
            "::",
            stringify!(vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtd_index) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svr),
            "::",
            stringify!(dtd_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t7_t10_vtdb_index) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_svr),
            "::",
            stringify!(t7_t10_vtdb_index)
        )
    );
}
#[doc = " Video Format Preference Data Block, defined in section 7.5.12."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct di_cta_video_format_pref_block {
    pub svrs: *const *const di_cta_svr,
}
#[test]
fn bindgen_test_layout_di_cta_video_format_pref_block() {
    const UNINIT: ::std::mem::MaybeUninit<di_cta_video_format_pref_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<di_cta_video_format_pref_block>(),
        8usize,
        concat!("Size of: ", stringify!(di_cta_video_format_pref_block))
    );
    assert_eq!(
        ::std::mem::align_of::<di_cta_video_format_pref_block>(),
        8usize,
        concat!("Alignment of ", stringify!(di_cta_video_format_pref_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(di_cta_video_format_pref_block),
            "::",
            stringify!(svrs)
        )
    );
}
extern "C" {
    #[doc = " Get the Video Format Preference information from a CTA data block.\n\n Returns NULL if the data block tag is not\n DI_CTA_DATA_BLOCK_VIDEO_FORMAT_PREF."]
    pub fn di_cta_data_block_get_video_format_pref(
        block: *const di_cta_data_block,
    ) -> *const di_cta_video_format_pref_block;
}
